#+OPTIONS: broken-links:mark
* FXRuby Enhancement Table of Contents                             :TOC_5_gh:
 - [[#fxruby-enhancement][fxruby-enhancement]]
   - [[#showcase][Showcase]]
   - [[#introduction][Introduction]]
   - [[#installation][Installation]]
   - [[#documentation][Documentation]]
     - [[#in-general][In General]]
       - [[#the-use-of--vs-doend-to-define-your-blocks][The use of {...} vs do...end to define your blocks]]
     - [[#execution-phases-of-fxruby-enhancement][Execution Phases of fxruby-enhancement]]
       - [[#declarative][Declarative]]
       - [[#fxruby-instantiation][FXRuby Instantiation]]
       - [[#fox-toolkit-instantiation][FOX Toolkit instantiation]]
     - [[#events-from-other-threads][Events from other Threads]]
       - [[#the-queue_ding-queues][The Queue_Ding Queues]]
         - [[#enhancementingress][Enhancement.ingress]]
         - [[#enhancementegress][Enhancement.egress]]
     - [[#reusable-components-and-dynamic-creation-and-the-reuse-flag][Reusable components and dynamic creation, and the 'reuse' flag]]
     - [[#api--dsl][API & DSL]]
       - [[#ref-refc-and-tagging-your-objects][ref(), refc() and tagging your objects]]
       - [[#as----adding-new-child-components-to-already-declared-ones][as -- adding new child components to already declared ones]]
       - [[#fox_component-and-fox_instance][fox_component and fox_instance]]
       - [[#fx_app][fx_app]]
       - [[#fx_chart][fx_chart]]
         - [[#data-format-and-labeling][Data Format and Labeling]]
         - [[#fonts][Fonts]]
       - [[#fx_data_target][fx_data_target]]
       - [[#fx_dc][fx_dc]]
       - [[#instance][instance]]
       - [[#ingress_handler][ingress_handler]]
       - [[#starten-and-stoppen-with-resuable-components][#starten and #stoppen with resuable components]]
       - [[#deferred_setup][deferred_setup]]
       - [[#mapping-between-fx_-declarations-and-the-fx-fxruby-objects][Mapping between fx_* declarations and the FX* FXRuby objects]]
       - [[#bindingfx][binding.fx]]
     - [[#color-directives][Color Directives]]
     - [[#examples][Examples]]
       - [[#hello-world-example-full-the-enhancement-way][Hello World example (full) the Enhancement Way]]
       - [[#hello-world-the-old-fxruby-way][Hello World the old fxruby way:]]
       - [[#bouncing-ball-example-full][Bouncing Ball example (full):]]
       - [[#bouncing-ball-the-old-fxruby-way][Bouncing Ball the old fxruby way:]]
       - [[#datatarget-example][DataTarget Example]]
   - [[#release-notes][Release Notes]]
   - [[#known-issues][Known Issues]]
   - [[#contributing-to-fxruby-enhancement][Contributing to fxruby-enhancement]]
   - [[#copyright-and-licensing][Copyright and Licensing]]
   - [[#the-junkyard--scratchpad][The Junkyard / Scratchpad]]
     - [[#junkyard-genesis-of-the-meta-meta-programming-whereby-brain-goes-boom][JUNKYARD Genesis of the meta-meta programming, whereby brain goes boom]]
     - [[#junkyard-resuable-components-and-data-targets][JUNKYARD Resuable components and data targets]]
       - [[#junkyard-data-targets][JUNKYARD Data Targets]]
     - [[#junkyard-subtle-ruby-bug-detected-chartrb-ruby-240][JUNKYARD Subtle Ruby Bug detected. (chart.rb) Ruby 2.4.0]]
     - [[#junkyard-as-execution-issue-debugging-code][JUNKYARD 'as' execution issue DEBUGGING CODE]]
     - [[#scratchpad-fxdcwindow][SCRATCHPAD FXDCWindow]]
     - [[#junkyard-thoughs-on-doing-the-layout][JUNKYARD Thoughs on doing the layout]]
     - [[#scratchpad-fxfont-hints][SCRATCHPAD FXFont Hints]]

* fxruby-enhancement
  #+caption: Enhancement vs. FXRuby versions of Hello World.
  #+name: fig:hello-world
  [[./examples/images/hello-world-new-and-old.png]]
  - On the left: Enhancement version of hello world.
  - On the right: FXRuby version.
** Showcase
   | Screenshot                           | Code Links     |
   |--------------------------------------+----------------|
   | [[./examples/images/hello.rb.png]]       | [[file:./examples/hello.rb][Hello World]]    |
   | [[./examples/images/dialog_box.rb.png]]  | [[file:,/examples/dialog_box.rb][Dialog Box]]     |
   | [[./examples/images/bounce.rb.png]]      | [[file:./examples/bounce.rb][Bounce]]         |
   | [[./examples/images/scribble.rb.png]]    | [[file:./examples/scribble.rb][Scribble]]       |
   | [[./examples/images/chart.rb.png]]       | [[file:./examples/chart.rb][Chart]]          |
   | [[./examples/images/rubyneat-panel.png]] | [[https://github.com/flajann2/rubyneat-panel/tree/master/lib/rubyneat-panel][RubyNEAT Panel]] |
   | [[./examples/images/color_chart.png]]    | [[./examples/color_chart.rb][Color Chart]]    |

** Introduction
   The fxruby library is an excellent wrapper for the FOX Toolkit.
   However, it reflects the C++-ness of FOX, rather than being more
   Ruby-like. As such, creating composed objects with it tends to be
   rather cumbersome, given its C++ roots. For every new component you create with
   fxruby, you are handed back a reference to that object, which you'll
   need to store somewhere. And then all the subsequent child objects
   will need to be passed pointers to the parent objects.

   So, if you need to redo a layout, it becomes a messy exercise.

   fxruby-enhancement makes this a snap to do. You simply declare
   your GUI arrangement in a nested fashion. fxruby-enhancement will
   take care of passing parents to the nested children, and other issues
   as well. You can now focus on creating your great GUI layout that you
   can change on the fly without much fuss and bother.

   fxruby-enhancement (also referred to as "Enhancement") is basically a
   DSL of sorts, and every effort has been taken to make it intuitive to
   use. Once you get the hang of it, you should be able to look at the
   FXRuby API documentation and infer the DSL construct for fxruby-enhancement.
   Please also see the many [[file:examples][examples]].
   
   Enhancement basically leverages Ruby's singleton feature, and eliminates
   the need to "subclass" the FXRuby objects and the like. In fact, you might
   even consider this Enhancement's own "paradigm" for doing GUI programming.

   Your input and criticisms are more than welcome. Feel free to raise
   issues on GitHub. I have not anticipated all the ways someone might try
   to use Enhancement. I am making heavy use of Enhancement in my RubyNEAT
   project -- which is why I created it.

   [[https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=4AZLVF9WH9J3C&lc=US&item_name=FXRuby%20Enhancement&item_number=enhancement&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted][Donations are appreciated.]]

** Installation
   To install the gem from commandline:

   #+begin_src bash
   gem install fxruby-enhancement
   #+end_src

   In your Gemfile:

   #+begin_src ruby
   gem "fxruby-enhancement", "~> 0"
   #+end_src

   fxruby-enhacement depends on fxruby version 1.6, and
   will automatically include it. However fxruby has a c-extension
   that must compile properly on your system. Normally, this is not
   a concern, but it is something to be aware of.
   
** Documentation
*** In General
    fxruby-enhancement (which we will refer to as "Enhancement" from time
    to time) makes use of the singleton pattern in Ruby. There is basically
    no need to declare subclases off of most FXRuby classes. This is a very
    C++ish way, and the way the C++ Fox Toolkit works. It will make most
    hard-core Rubyists gnash their teeth.

    Here, we do away with all of it. Also, the SEL_x variables -- which maps
    to the C++ #defines of the same -- is replaced with method declarations
    of the nature of sel_x -- just the lowercase version of the same. For instance,
    in the straight fxruby, you would have to do something like:

    #+begin_src ruby
    @canvas.connect(SEL_PAINT) { |sender, sel, evt|
      FXDCWindow.new(sender, evt) { |dc|
        dc.drawImage(@backBuffer, 0, 0)
      }
    #+end_srcv

    but with Enhancement, you do it thusly:

    #+begin_src ruby
    instance { |c|
      c.sel_paint { |sender, sel, event|
        FXDCWindow.new(sender, event) { |dc|
          dc.drawImage(ref(:back_buffer), 0, 0)
        }
      }
    }
    #+end_src
    
    And here we illustrate something else, the instance declaration. Why do
    we do it this way? Because Enhancement is multi-phase. First, we declare
    the GUI layout with Enhancement. At this time, none of the underlying
    FXRuby objects exist yet, but need to be referenced anyway. So we defer
    that part where references need to be resolved to the instance claus,
    which, as you can well imagine, means the FXRuby object instances have
    been instantiated.

    You will also note the use of the ref clause, as in:
    #+begin_src ruby
    dc.drawImage(ref(:back_buffer), 0, 0)
    #+end_src
    
    When the :back_buffer object was declared, it was done thusly:
    #+begin_src ruby
    fx_image(:back_buffer) { opts IMAGE_KEEP }
    #+end_src

    So when the actual FXImage object is instantiated, it is associated to
    the :back_buffer tag, which then is found by ref() and can be used
    anywhere in the instantiation phase.
**** The use of {...} vs do...end to define your blocks
     This is something to be aware of, depending on
     how you'd like to style your code for Enhancement.
     I prefer the use of the braces {}, but others
     might prefer the use of do...end.

     Even though Ehnancement is a bit "opionated", I don't
     wish to impose a coding style on you. But I do wish
     to alert you to the subtle difference in syntax
     that Ruby expects.

     If you use the braces, you must enclose the
     parameters to the directive in parens (). If
     you use do...end, you have no such requirement.
     for example, to use do...end:
     #+begin_src ruby
     fx_app :app do
       ...
     end
     #+end_src

     is perfectly OK, whereas:
     #+begin_src ruby
     fx_app :app {
       ...
     }
     #+end_src

     would generate a syntax error. You must, in this case:
     #+begin_src ruby
     fx_app (:app) {
       ...
     }
     #+end_src

     And that won't get your hands slapped by the Ruby
     parser.

*** Execution Phases of fxruby-enhancement
    This represents the work flow, in the order stated:
    | State                     | Description                                                                                                                  |
    |---------------------------+------------------------------------------------------------------------------------------------------------------------------|
    | Declarative               | The basic GUI layout is declared by the DSL, but it is not instantiated yet.                                                 |
    | FXRuby instantiation      | All the basic underlying FXRuby object are instantiatied, but the foundational FOX Toolkit Objects are not instantiated yet. |
    | FOX Toolkit instantiation | The FOX Toolkit C++-level objects are now alive and kicking.                                                                 |

**** Declarative
     This phase, under the proverbial hood, ceates the component objects,
     which are just place-holders for the underlying FXRuby objects.

     When the FXRuby object is created, it is assigned to its place holder
     component object, and can be references as comp.inst. In most cases,
     you will almost never need to touch the component objects directly.
**** FXRuby Instantiation
     During the FXRuby instantiantion stage, all of the FXRuby
     objects are instantiated and stored in their respective
     component objects. If they are tagged, the instantiated
     object may be referenced with ref(), and the component 
     object itself may be referenced via refc(). There is almost 
     never a case where you would need to go after the component
     object directly.
**** FOX Toolkit instantiation
     All of the FOX Toolkit C++ objects, resources, etc. that
     correspond to the FXRuby objects are now set up, and activated.
     With the all-important "show PLACEMENT_SCREEN" command, the
     FOX GUI should now be visible.
*** Events from other Threads
    In handling interfacing to databases, AMQPs like RabbitMQ,
    network connections, or just about anything else that might otherwise
    slow down the GUI (Fox) thread and make it non-responsive, there needs 
    to be a clean way to get data into and out of the GUI thread.

    Fox provides some mechanisms specifically for sockets or system-level IO,
    but these are too specific, and would require some awkard workarounds to
    make them work in the general context.

    And so we provide a means to accomplish that in a clean -- to you, anyway --
    manner. We make use of queue_ding queues for passing messages into and out of
    the FXRuby (and therefore FXRuby Enhancement) space. This will allow you to
    keep the GUI thread responsive and also to maintain a seperation of concerns.
**** The Queue_Ding Queues
     [[ttps://github.com/flajann2/queue_ding][Queue Ding]] is an enhancement for doing queing across threads in Ruby,
     and we offer it here to allow external events to be funneled into and
     out of the Fox GUI thread. Usage is easy and straightforard. When
     removing entries from Queue Ding using #next, the queue will block until
     the next entry arrives. Since Queue Ding is really derived from ::Array,
     you may also do thing like #empty? to check to see if entries are availabe
     to avoid blocking.
***** Enhancement.ingress
      To get messages objects into fxruby_enhacement, simply #push or #<<
      it into the queue as shown:
      #+begin_src ruby
      Enhancement.ingress << [:some_tag, some_payload]
      #+end_src

      In the DSL, you must set up a handler for the ingress,
      #+begin_src ruby
      ingress_handler :status do |tag, payload|
        puts "received #{tag} => #{payload}"
      end
      #+end_src

      And so your handler will most likely act as a dispatcher
      for the payloads received. For example:
      #+begin_src ruby
      ingress_handler :log_info, :log_error do |tag, logline|
        puts "received #{tag} => #{payload}"
        case tag
        when :log_info
          ref(:logging_info).appendItem logline
        when :log_error
          ref(:logging_error).appendItem logline
        end
      end
      #+end_src

      Note that this ingress handler is responding to two tags. You can have
      as many tags as you like for your ingress handler, and as many
      ingress handlers as you like. 
      
      Currently, all the tags should be unique. Later we may support having 
      multiple blocks associated with the same tag. Please feel free to generate
      an issue if you want this!!!

***** Enhancement.egress
      Wnen your Fox application needs to send a message to other
      listening threads, You simply push your payload onto the egress queue
      thusly:
      #+begin_src ruby
      Enhancement.egress << [:button_clicked, "I was clicked!"]
      #+end_src

      and your Ruby thread external to Fox would simply do:
      #+begin_src ruby
      ...
      message = Enhancement.egress.next
      ...
      #+end_src
      
      where you'll block pending the arrival of the next message. If you
      do not wish to block, you may do:
      #+begin_src ruby
      ...
      unless Enhancement.egress.empty?
        message = Enhancement.egress.next 
      else
        # some action to take
      end
      ...
      #+end_src

*** Reusable components and dynamic creation, and the 'reuse' flag
    There are times you may want to be able to create, and popup, say, a dialog
    box, or perhaps you want to create on the fly child components on an
    existing window.

    This is made possible with the "reuse: true" flag. For example:
    #+begin_src ruby
    fx_dialog_box(:dialog, reuse: true) {
      title "I am a Dialog!"
      opts DECOR_ALL
      
      fx_button {
        text "&It Works!"
        instance { |dia|
          dia.sel_command {
            refc(:dialog).stoppen
          }
        }
      }      
      instance { |dia| dia.show PLACEMENT_OWNER  }
    }
    #+end_src

    This code snippet can be run in the context of the app or a window. 
    If you do it in a window context, that window will become the "owner",
    and will initially be placed hovering over it.

    With reusable components, you will use the #starten and #stoppen methods
    to create and destroy the component. Please see
    the [[file:examples/dialog_box.rb][Dialog Box]] for a full example, and also
    the docs for #starten and #stoppen.

*** API & DSL
**** ref(), refc() and tagging your objects
     In an effort to eliminate the fuss and bother with
     scoping issues and object reference, ref(:some_tag) will
     retrive the FXRuby instance object so tagged with :some_tag.

     You may have anonymous, i.e., untagged objects, and those will
     not be findable by ref(). It is not necessary to tag all objects,
     either.

     refc() is similar to ref(), except it retrives the underlying 
     component object insted. Indeed, the following are equivalent
     operations:
     #+begin_src ruby
     ref(:some_tag)
     refc(:some_tag).inst
     #+end_src

     Where might you want to use refc() instead of ref()? In cases
     where the underlying FXRuby object have not been instantiated yet,
     you'd use refc() instead of ref(), almost always during the component
     configuration. For example:
     #+begin_src ruby
     fx_app :app do
     ...
       fx_button {
         text "&See Ya!"
         selector FXApp::ID_QUIT
         target refc(:app)
       }
     ...
     #+end_src
     
     Here, we set the button to exit the application by sending the FXApp object the ID_QUIT
     message. But at the time we set the configuration, the FXApp object has not been instantiated
     yet. So we use refc() instead of ref().
     
     Underlying, the component object is really a subclass of OpenScript.
     While you may like to stuff some additional data there, 
     this is frowned upon because it might conflict with Enhancement.
     If you have a need for this, please do a issue in GitHub.

**** as -- adding new child components to already declared ones
     The 'as' clause allow you to shift context back
     to a previously defined component, so that you
     can factor your code in a way to promote
     encapsulation.

     This is especially useful in large projects
     where you are making heavy use of binding.fx
     to modularize your GUI layout. It helps
     you keep everything related in one place.

     For example, deep within a 
     window definition, you made need to define
     an image to be used by a widget. However,
     the image needs to be defined in the fx_app
     context, taking it far away from where
     it is actially needed. Here's an example of how
     you would do that:
     #+begin_src ruby
     fx_main_window(:bounce_window) {
       title "Bounce Demo"
       ...
       as (:app) {
         fx_image(:back_buffer) { opts IMAGE_KEEP }
       }
       ...
     #+end_src

     As you can see, your components will need to be tagged
     to be referenced by 'as'.

**** fox_component and fox_instance
     fox_component and fox_instance are roughly the
     equivalent of refc() and ref(), respecively. The
     difference mainly being that fox_component does no
     sanity checking, and is therefore slightly faster.

     At some point, they may be merged, but for now don't 
     count on it.

     To initialize and run your app, you customairly do the
     following:
     #+begin_src ruby
     fox_component :app do |app|
       app.launch
     end
     #+end_src

     Which presumes your fx_app declaration was tagged with
     :app as follows:
     #+begin_src ruby
     fx_app :app do
       app_name "Your Amazingly Cool Application"
       vendor_name "YouDaMan"
       ...
     end
     #+end_src

     This is the only time you will reference the component
     object directly for the obvious reason that you must start
     from someonere.

**** fx_app
     To begin the declaration of your app, you must do the
     following somewhere:
     #+begin_src ruby
     fx_app :app do
       app_name "The Forbin Project"
       vendor_name "Colossus"
       ...
     end
     #+end_src

     Typeically you'd do this inside of a module, but you could do it also
     in a class body. Please see the examples.

**** fx_chart
     fx_chart is a custom widget supplied by Enhancement,
     and provides very simple charting abilities. We have mainly created
     this with the needs of RubyNEAT in mind, but hopefully we will
     eventually grow the scope of what fx_chart can do.

     Initally, we provide basic x-y Cartesian charting suitable for
     representing time series, etc. 
***** Data Format and Labeling
      Data is in the format of an array of vectors,
      with each update adding a new vector to the array. For example:
      #+begin_src ruby
      [
      [1, 22.1, 34.2, 11],
      [2, 23.4, 25.0, 14],
      [3, 25.2, 35.2, 12],
      [4, 21.9, 63.3, 11],
      [5, 11.4, 50.1, 20],
      ]
      #+end_src

      Even though the "vectors" are themselves arrays, we shall refer
      to them as such for the sake of this discussion.

      You may specify the first entry in the vector as the range, 
      in which case it will be used to plot the rest of the vector
      as the "range" on the chart.
****** Labeling Series Data
       Each entry in the vectors must have some sort of 
       designation to describe how the chart will display them.
       So we represent this as an association of labels, and each
       label will define how the data from that position in the
       vector will be drawn and labeled. For example:
       #+begin_src ruby
       {
         0 => {
           label: 'x-axis',
           type: :range
           },
         1 => {
           label: 'Germany',
           type: :data,
           color: :yellow,
           thickness: 3
           },
         2 => {
           label: 'Poland',
           type: :data,
           color: :blue,
           thickness: 1
           },
         3 => {
           label: 'Östereich',
           type: :data,
           color: :green,
           thickness: 2
         },
       }
       #+end_src

       Specifying the position of the vector as keys in the hash
       will allow us to "leave gaps" in the specification, particulary
       when the number of entries in that vector become large.

***** Fonts
      Here are a list of fonts across all the major platforms: [[http://www.apaddedcell.com/sites/www.apaddedcell.com/files/fonts-article/final/index.html][Preinstalled Fonts]]

**** fx_data_target
     FOX (and therefor FXRuby) supports data synchronization among components.
     fx_data_target encapsulates the FXDataTarget class, just like all the
     other fx_* directives do. However, in this case, some special treatment
     is necessary since it is referenced at a time the underlying FXRuby
     object has not been created yet.

     Enter refc(). You use refc(), instead of ref(), to use it when you are
     configuring the component (really, specifying the initial parameters
     to the underlying FXRuby class!) We illustrate here:
     #+begin_src ruby
     ...
     fx_data_target (:mydata) { value "initial value"  }
     ...
     fx_text (:text_3) {
       target refc(:mydata)
       selector FXDataTarget::ID_VALUE
     }
     fx_text (:text_4) {
       target refc(:mydata)
       selector FXDataTarget::ID_VALUE
     }
     #+end_src

     And so the two text components  -- or widgets -- are initially
     set to the value of "initial value", and when one changes, the
     other is instantly updated.

     Otherwise, you can deal with fx_data_target as expected. See
     the [[#datatarget-example][DataTarget Example]].

**** fx_dc
     For canvas work, you typically have to create and
     destory the FXDCWindow object. To ease this, use the
     fx_dc instead. For example:
     #+begin_src ruby
     button.sel_command {
       fx_dc :canvas do |dc|
         dc.foreground = ref(:canvas).backColor
         dc.fillRectangle(0, 0, ref(:canvas).width, ref(:canvas).height)
         @dirty = false
       end
     }
     #+end_src

     instead of:
     #+begin_src ruby
     button.sel_command {
       FXDCWindow.new(ref(:canvas)) do |dc|
         dc.foreground = ref(:canvas).backColor
         dc.fillRectangle(0, 0, ref(:canvas).width, ref(:canvas).height)
         @dirty = false
       end
     }
     #+end_src
     
     This example has been borrowed from [[file:./examples/scribble.rb][Scribble]].

**** instance
     Inside of your component declaration, you will undoubtly
     want to specify what you want to do once the FXRuby object
     is actually instantiated. This is what the instance clause
     will allow you to do. Your code block there will be passed
     a reference to the FXRuby object, allowing you to set up
     connections, change the component state, etc.

     There are some added benefits as well. When making a connection,
     with the normal FXRuby, you would do something like this:
     #+begin_src ruby
     ...
     aButton.connect(SEL_COMMAND)  { |sender, selector, data|
       ... code to handle this event ...
     }
     #+end_src

     But with Enhancement, you would be able to do it thusly:
     #+begin_src ruby
     fx_button(:my_button) {
       ... configs for this FXButton object ...
       instance { |button|
         button.sel_command { |sender, selector, data|
           ... code to handle this event ...
         }
       }
     }
     #+end_src

     which will make it feel more Ruby-like and less C++-like.

**** ingress_handler
     ingress_handler will allow you to set up the handler for
     messages coming in from an external source to FXRuby thread,
     such as RabbitMQ, network connections, databases, or anything else.
     It allows you to do clean multhreaded Ruby without the normal worries
     of semaphores and synchronization and the like -- it is all
     handled for you "magically" behind the scenes!

     You may have as many ingress_handlers specified as you like, as
     each one needs to have a tag, and the tags are used to dispatch
     the messages.

     Here is an example taken from RubyNEAT Panel:
     #+begin_src ruby
     ingress_handler :status do |type, status|
       suc, st = status.response
      
       wlist = ref :ov_conn_neaters_widget_list
       wlist.clearItems
       st[:neaters].each { |neater| wlist.appendItem neater }

       nlist = ref :ov_conn_neurons_list
       nlist.clearItems
       st[:neurons].each { |neuron| nlist.appendItem neuron}
     end
     #+end_src
     
     Here you can see that a status message has been dispatched to 
     this ingress_handler, and that the message contains a list of
     'neaters' and 'neurons' that are being sent to the wlist
     and nlist list (:ov_conn_neaters_widget_list and :ov_conn:_neurons_list),
     respecively.

     You may declare your ingress_handler anywhere in your code and have 
     the expected happen.

     igress_handler may also be specified with more than one tag, for
     instance:
     #+begin_src ruby
     ingress_handler :warn, :info, :error do |type, log|
       case type
       when :warn
         ...
       when :info
         ...
       when :error
         ...
       else
         raise "Unknown log type"
       end
     end
     #+end_src

     The same block is assigned to all the given tags of :warn, :info, and :error.

**** #starten and #stoppen with resuable components
     To designate a component as reusable, declare it with "reuse: true"
     as in the example:
     #+begin_src ruby
     fx_dialog_box(:dialog, reuse: true) { ... }
     #+end_src

     Then in the instance clause or to the response to an event,
     you would do:
     #+begin_src ruby
     refc(:dialog).starten
     #+end_src

     to activate it, and
     #+begin_src ruby
     refc(:dialog).stoppen
     #+end_src

     to deactive it (and remove the 'server'-side FOX components!)

     Note that you call refc(), not ref() in this case, because the
     functionality lies in the component object holder for the actual
     FOX component, not within the FXRuby object itself.

**** TODO deferred_setup
**** TODO Mapping between fx_* declarations and the FX* FXRuby objects
**** binding.fx   
     This is a way to split up your layouts into different .fx "modules", purely for
     organizational reasons. For example,

     #+begin_src ruby
     binding.fx "overview"
     #+end_src

     will load the overview.fx portion of the GUI, which happens to be a tab contents
     in the tab book, which in our case looks like:

     #+begin_src ruby
     # Overview Tab

     fx_tab_item { text "&Overview" }
     fx_horizontal_frame (:overview_info) {
       opts STD_FRAME|LAYOUT_FILL_Y
  
       fx_group_box (:ov_connections_group) {
         text "Connections"
         opts STD_GROUPBOX|LAYOUT_FILL_Y
    
         fx_vertical_frame {
           opts LAYOUT_FILL_Y|LAYOUT_FILL_X #|PACK_UNIFORM_HEIGHT
      
           fx_group_box (:ov_conn_rabbitmq) {
     ...
     #+end_src
    
*** Color Directives
    For convience, when dealing with colors in the device context or any
    other situation, we provide you with a nice set of predefined colors.
    [[./examples/images/color_chart.png]]
    
    A code snippet example for using the color directives:
    #+begin_src ruby
    fx_button {
      text "Red Button"
      instance { |b|
        b.backColor = red
        b.textColor = black
      }
    }
    #+end_src

    Look to [[./examples/color_chart.rb][Color Chart]] for a
    more extensive example.

*** Examples
    Because this is a spinoff project of the ongoing RubyNEAT
    effort, there is a splendid RubyNEAT Panel example, that
    is still in the works. However, you are free to look at the
    code that is there to get good ideas.

    https://github.com/flajann2/rubyneat-panel/tree/master/lib/rubyneat-panel

    Class-based Enhancement (this is currently not supported!!!):
    #+begin_src ruby
    class Main < FXMainWindow
      compose :my_window do
        title "RubyNEAT Panel"
        show PLACEMENT_SCREEN
        width 700
        height 400
        fx_tab_book :my_book do |tab_book_ob|
          x 0
          y 0
          width 500
          height 100
          pad_bottom 10
          fx_text :my_text1, :my_window { |text_ob|
            width 200
            height 100
            text_ob.target my_window: :on_click
          }
          fx_text :my_text2, :my_window { |text_ob|
            width 200
            height 100
            text_ob { |t| puts "called after object initialization" }
          }
        end
      end

      def on_click
        ...
      end
    end    
    #+end_src

    Class-free Enhancement (strongly recommended):
    #+begin_src ruby
    mw = fx_main_window :my_window do 
        title "RubyNEAT Panel"
        width 700
        height 400
        opts DECOR_ALL
        x 10
        y 10
        instance { show PLACEMENT_SCREEN }
        fx_tab_book :my_book do |tab_book_ob|
          x 0
          y 0
          width 500
          height 100
          pad_bottom 10
          fx_text :my_text1, :my_window { |text_ob|
            width 200
            height 100
            instance my_window: :on_click
          }
          fx_text :my_text2, :my_window { 
            width 200
            height 100
            instance { |t| puts "called after object initialization" }
          }
        end
      end

      def mw.on_click
        ...
      end
    end    
    #+end_src

**** [[file:examples/hello.rb][Hello World]] example (full) the Enhancement Way
    #+begin_src ruby
#!/usr/bin/env ruby
require 'fxruby-enhancement'

include Fox
include Fox::Enhancement::Mapper

fx_app :app do
  app_name "Hello"
  vendor_name "Example"

  fx_main_window(:main) {
    title "Hello"
    opts DECOR_ALL

    fx_button {
      text "&Hello, World"
      selector FXApp::ID_QUIT
      
      instance { |b|
        b.target = ref(:app)
      }
    }

    instance { |w|
      w.show PLACEMENT_SCREEN
    }
  }
end

# alias for fox_component is fxc
fox_component :app do |app|
  app.launch
end
    #+end_src
    
**** Hello World the old fxruby way:
    #+begin_src ruby
#!/usr/bin/env ruby

require 'fox16'

include Fox

application = FXApp.new("Hello", "FoxTest")
main = FXMainWindow.new(application, "Hello", nil, nil, DECOR_ALL)
FXButton.new(main, "&Hello, World!", nil, application, FXApp::ID_QUIT)
application.create()
main.show(PLACEMENT_SCREEN)
application.run()
    #+end_src

    Even though the old way has a slightly smaller line count, you can
    see how messy it can be assigning each newly-created object to
    a variable, and then having to pass that variable to the children.
    Perhaps this example is too small, but perhaps the next one will
    more illustrative.

**** [[file:examples/bounce.rb][Bouncing Ball]] example (full):
    #+begin_src ruby
#!/usr/bin/env ruby
require 'fxruby-enhancement'

include Fox
include Fox::Enhancement::Mapper

ANIMATION_TIME = 20

class Ball
  attr_reader :color
  attr_reader :center
  attr_reader :radius
  attr_reader :dir
  attr_reader :x, :y
  attr_reader :w, :h
  attr_accessor :worldWidth
  attr_accessor :worldHeight

  
  def initialize r
    @radius = r
    @w = 2*@radius
    @h = 2*@radius
    @center = FXPoint.new(50, 50)
    @x = @center.x - @radius
    @y = @center.y - @radius
    @color = FXRGB(255, 0, 0) # red
    @dir = FXPoint.new(-1, -1)
    setWorldSize(1000, 1000)
  end
  
  # Draw the ball into this device context
  def draw(dc)
    dc.setForeground(color)
    dc.fillArc(x, y, w, h, 0, 64*90)
    dc.fillArc(x, y, w, h, 64*90, 64*180)
    dc.fillArc(x, y, w, h, 64*180, 64*270)
    dc.fillArc(x, y, w, h, 64*270, 64*360)
  end

  def bounce_x
    @dir.x=-@dir.x
  end

  def bounce_y
    @dir.y=-@dir.y
  end

  def collision_y?
    (y<0 && dir.y<0) || (y+h>worldHeight && dir.y>0)
  end

  def collision_x?
    (x<0 && dir.x<0) || (x+w>worldWidth && dir.x>0)
  end

  def setWorldSize(ww, wh)
    @worldWidth = ww
    @worldHeight = wh
  end
  
  def move(units)
    dx = dir.x*units
    dy = dir.y*units
    center.x += dx
    center.y += dy
    @x += dx
    @y += dy
    if collision_x?
      bounce_x
      move(units)
    end
    if collision_y?
      bounce_y
      move(units)
    end
  end
end

fx_app :app do
  app_name "Bounce"
  vendor_name "Example"

  fx_image(:back_buffer) { opts IMAGE_KEEP }
  
  fx_main_window(:bounce_window) {
    title "Bounce Demo"
    opts DECOR_ALL
    width 400
    height 300
    
    instance { |w|
      def w.ball
        @ball ||= Ball.new(20)
      end
      
      def w.drawScene(drawable)
        FXDCWindow.new(drawable) { |dc|
          dc.setForeground(FXRGB(255, 255, 255))
          dc.fillRectangle(0, 0, drawable.width, drawable.height)
          ball.draw(dc)
        }
      end
      
      def w.updateCanvas
        ball.move(10)
        drawScene(ref(:back_buffer))
        ref(:canvas).update
      end
      
      #
      # Handle timeout events
      #
      def w.onTimeout(sender, sel, ptr)
        # Move the ball and re-draw the scene
        updateCanvas
        
        # Re-register the timeout
        ref(:app).addTimeout(ANIMATION_TIME, ref(:bounce_window).method(:onTimeout))
        
        # Done
        return 1
      end
      
      w.show PLACEMENT_SCREEN
      ref(:app).addTimeout(ANIMATION_TIME, w.method(:onTimeout))
    }
    
    fx_canvas(:canvas) {
      opts LAYOUT_FILL_X|LAYOUT_FILL_Y
      
      instance { |c|
        c.sel_paint { |sender, sel, event|
          FXDCWindow.new(sender, event) { |dc|
            dc.drawImage(ref(:back_buffer), 0, 0)
          }
        }

        c.sel_configure{ |sender, sel, event|
          bb = ref(:back_buffer)
          bb.create unless bb.created?
          bb.resize(sender.width, sender.height)
          ref(:bounce_window) do |bw|
            bw.ball.setWorldSize(sender.width, sender.height)
            bw.drawScene(bb)
          end
        }
      }
    }
  }
end

if __FILE__ == $0
  # alias for fox_component is fxc
  fox_component :app do |app|
    app.launch
  end
end
    #+end_src

**** Bouncing Ball the old fxruby way:
    #+begin_src ruby
require 'fox16'

include Fox

# How long to pause between updates (in milliseconds)
ANIMATION_TIME = 20

class Ball

  attr_reader :color
  attr_reader :center
  attr_reader :radius
  attr_reader :dir
  attr_reader :x, :y
  attr_reader :w, :h
  attr_accessor :worldWidth
  attr_accessor :worldHeight

  # Returns an initialized ball
  def initialize(r)
    @radius = r
    @w = 2*@radius
    @h = 2*@radius
    @center = FXPoint.new(50, 50)
    @x = @center.x - @radius
    @y = @center.y - @radius
    @color = FXRGB(255, 0, 0) # red
    @dir = FXPoint.new(-1, -1)
    setWorldSize(1000, 1000)
  end

  # Draw the ball into this device context
  def draw(dc)
    dc.setForeground(color)
    dc.fillArc(x, y, w, h, 0, 64*90)
    dc.fillArc(x, y, w, h, 64*90, 64*180)
    dc.fillArc(x, y, w, h, 64*180, 64*270)
    dc.fillArc(x, y, w, h, 64*270, 64*360)
  end

  def bounce_x
    @dir.x=-@dir.x
  end

  def bounce_y
    @dir.y=-@dir.y
  end

  def collision_y?
    (y<0 && dir.y<0) || (y+h>worldHeight && dir.y>0)
  end

  def collision_x?
    (x<0 && dir.x<0) || (x+w>worldWidth && dir.x>0)
  end

  def setWorldSize(ww, wh)
    @worldWidth = ww
    @worldHeight = wh
  end

  def move(units)
    dx = dir.x*units
    dy = dir.y*units
    center.x += dx
    center.y += dy
    @x += dx
    @y += dy
    if collision_x?
      bounce_x
      move(units)
    end
    if collision_y?
      bounce_y
      move(units)
    end
  end
end

class BounceWindow < FXMainWindow

  include Responder

  def initialize(app)
    # Initialize base class first
    super(app, "Bounce", :opts => DECOR_ALL, :width => 400, :height => 300)

    # Set up the canvas
    @canvas = FXCanvas.new(self, :opts => LAYOUT_FILL_X|LAYOUT_FILL_Y)

    # Set up the back buffer
    @backBuffer = FXImage.new(app, nil, IMAGE_KEEP)

    # Handle expose events (by blitting the image to the canvas)
    @canvas.connect(SEL_PAINT) { |sender, sel, evt|
      FXDCWindow.new(sender, evt) { |dc|
        dc.drawImage(@backBuffer, 0, 0)
      }
    }

    # Handle resize events
    @canvas.connect(SEL_CONFIGURE) { |sender, sel, evt|
      @backBuffer.create unless @backBuffer.created?
      @backBuffer.resize(sender.width, sender.height)
      @ball.setWorldSize(sender.width, sender.height)
      drawScene(@backBuffer)
    }

    @ball = Ball.new(20)
  end

  #
  # Draws the scene into the back buffer
  #
  def drawScene(drawable)
    FXDCWindow.new(drawable) { |dc|
      dc.setForeground(FXRGB(255, 255, 255))
      dc.fillRectangle(0, 0, drawable.width, drawable.height)
      @ball.draw(dc)
    }
  end

  def updateCanvas
    @ball.move(10)
    drawScene(@backBuffer)
    @canvas.update
  end

  #
  # Handle timeout events
  #
  def onTimeout(sender, sel, ptr)
    # Move the ball and re-draw the scene
    updateCanvas

    # Re-register the timeout
    getApp().addTimeout(ANIMATION_TIME, method(:onTimeout))

    # Done
    return 1
  end

  #
  # Create server-side resources
  #
  def create
    # Create base class
    super

    # Create the image used as the back-buffer
    @backBuffer.create

    # Draw the initial scene into the back-buffer
    drawScene(@backBuffer)

    # Register the timer used for animation
    getApp().addTimeout(ANIMATION_TIME, method(:onTimeout))

    # Show the main window
    show(PLACEMENT_SCREEN)
  end
end

if __FILE__ == $0
  FXApp.new("Bounce", "FXRuby") do |theApp|
    BounceWindow.new(theApp)
    theApp.create
    theApp.run
  end
end
    #+end_src
    
    The Ball class is the same, but the actual Fox-related code
    should clearly illustrate the power of Enhancement.

    More examples can be found [[file:examples][HERE]].

**** DataTarget Example
     fx_data_target (:some_name) must be referenced as refc(:some_name) and
     not ref(...). See the example below.

     #+begin_src ruby
#!/usr/bin/env ruby
require 'fxruby-enhancement'

include Fox
include Fox::Enhancement::Mapper

fx_app :app do
  app_name "DataTarget"
  vendor_name "Example"

  fx_data_target (:textx) { value "x marks the spot!"  }
  fx_data_target (:texty) { value "y do it?"  }
  
  fx_main_window(:main) {
    title "fx_data_target example"
    opts DECOR_ALL
    width 300
    x 100
    y 200

    fx_text_field (:text_1) {
      ncols 40
      target refc(:textx)
      selector FXDataTarget::ID_VALUE
    }
    fx_text_field (:text_2) {
      ncols 40
      target refc(:textx)
      selector FXDataTarget::ID_VALUE
    }
    fx_text (:text_3) {
      opts LAYOUT_FILL_X
      target refc(:texty)
      selector FXDataTarget::ID_VALUE
    }
    fx_text (:text_4) {
      opts LAYOUT_FILL_X
      target refc(:texty)
      selector FXDataTarget::ID_VALUE
    }
    fx_button {
      text "&See ya!"
      selector FXApp::ID_QUIT
      opts BUTTON_NORMAL|LAYOUT_CENTER_X
      
      instance { |b|
        b.target = ref(:app)
      }
    }
    
    instance { |w|
      w.show PLACEMENT_SCREEN
    }
  }
end

# alias for fox_component is fxc
fox_component :app do |app|
  app.launch
end
     #+end_src

** Release Notes
   | Version |       Date | Notes                                                       |
   |---------+------------+-------------------------------------------------------------|
   |   0.0.2 | 2017-01-11 | Initial release                                             |
   |   0.0.3 | 2017-01-15 | Needed to require fox16/colors for FXColor to be loaded     |
   |   0.0.4 | 2017-01-16 | ingress_handler now handles multiple tags.                  |
   |   0.1.0 | 2017-01-18 | special handling for fx_data_target and resuable components |

** Known Issues
   | Version | Date                   | Issues                                                                   |
   |---------+------------------------+--------------------------------------------------------------------------|
   |   0.0.2 | 2017-01-11             | Not enough example code!!! Need more documentation!!!                    |
   |   0.1.0 | Trump Inaguration Day, | deferred_setup not fully implemented, and may go away.                   |
   |         | 2017-01-20             | compose is not really needed, and is not fully implemented anyway.       |
   |   0.2.0 | Subtle Ruby Bug        | There are TODO notes in chart.rb, and there is something in The Junkyard |
   |         |                        | Bug moved into bug/ruby240 branch. Workaround now in place here.         |

** Contributing to fxruby-enhancement
 
   - Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet.
   - Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it.
   - Fork the project.
   - Start a feature/bugfix branch.
   - Commit and push until you are happy with your contribution.
   - Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
   - Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

** Copyright and Licensing
   Copyright (c) 2016-2017 Fred Mitchell. See [[file:LICENSE.txt][MIT License]] for
   further details.
** The Junkyard / Scratchpad
   These are my personal notes, not meant for anyone else.
   You may see some interesting tidbits here, but I am not
   gauranteeing anything to be useful or reliable in this
   section. YOU HAVE BEEN WARNED.
*** JUNKYARD Genesis of the meta-meta programming, whereby brain goes boom
    #+begin_src ruby
    class FXToolBar # monkey patch
      include Enhancement
      attr_accessor :_o
    end

    def fx_tool_bar name, &block # DSL
      o = OStruct.new
      o.title = "default title"
      ...

      def o.title t 
        @title = t
      end    

      def o.instance a, &block
        o.instance_time_block = block
      end
      f = FXToolBar.new ...
      f._o = o
    end

<% for @class, @details in @api %>
   #<%= @class %> < <%= @details[:class][1] %>
   <% unless @details[:initialize].nil? %>
      <% for @iniparams in @details[:initialize] %>
         #<%= @iniparams %>   
      <% end %>
   <% else %>
      #No initializer
   <% end %>
<% end %>
    #+end_src

*** JUNKYARD Resuable components and data targets
    We have an issue with needing to have reusable components
    (dialog boxes, say), and ṕroperly handling data targets designations.
**** JUNKYARD Data Targets
     Data targets cannot be done the same way we are doing the other
     fxruby components, because they have a different workflow. Basically,
     they need to be instantiated before the other comonents that uses
     them, and they are not really "child" objects, either. Referring to them
     using the ref() or refc() approach simply fails, because they won't
     be instantiated in time.

     We have ameroliated this problem by checking in the parameter list
     for an OpenStruct object, and calling #inst on it to pass in the instance,
     rather than the object itself. So now you simply use refc()
     in those cases.
     
*** JUNKYARD Subtle Ruby Bug detected. (chart.rb) Ruby 2.4.0
    This bug is a bit difficult to describe, but want to capture it here. It
    has to do with my "pushing the limits" of Ruby's metaprogramming features.
    #+begin_src ruby
module Fox
  module Enhancement
    module Mapper
      def fx_chart name = nil, ii: 0, pos: Enhancement.stack.last, reuse: nil, &block
        Enhancement.stack << (@os = os =
                              OpenStruct.new(klass: FXCanvas,
                                             op: [],
                                             ii: ii,
                                             fx: nil,
                                             kinder: [],
                                             inst: nil,
                                             instance_result: nil,
                                             reusable: reuse,
                                             type: :cartesian,
                                             axial: OpenStruct.new, #TODO: name changed to protect the innocent
                                             background: OpenStruct.new))
        Enhancement.components[name] = os unless name.nil?
        unless pos.nil?
          pos.kinder << os 
        else
          Enhancement.base = os
        end
        
        @os.op[0] = OpenStruct.new(:parent => :required,
                                   :target => nil,
                                   :selector => 0,
                                   :opts => FRAME_NORMAL,
                                   :x => 0,
                                   :y => 0,
                                   :width => 0,
                                   :height => 0)

        # Initializers for the underlying 
        def target var; @os.op[@os.ii].target = var; end
        def selector var; @os.op[@os.ii].selector = var; end
        def opts var; @os.op[@os.ii].opts = var; end
        def x var; @os.op[@os.ii].x = var; end
        def y var; @os.op[@os.ii].y = var; end
        def width var; @os.op[@os.ii].width = var; end
        def height var; @os.op[@os.ii].height = var; end
        
        # Chart specific
        def type var; @os.type = var; end

        #TODO: Subtle bug in Ruby 2.4.0 tripped over here with
        #TODO: the name of this funcion being the same as the
        #TODO: initialized variable in the OS, so I had to make
        #TODO: them different, hence the "axial".
        def axis ax, **kv
          ap @os.axial[ax] = OpenStruct.new(**kv)
        end

        def background **kv; kv.each{ |k,v| @os.background[k] = v }; end

        # What will be executed after FXCanvas is created.
        def instance a=nil, &block
          @os.instance_name = a
          @os.instance_block ||= []
          @os.instance_block << [a, block]
        end
        
        self.instance_eval &block
        
        os.fx = ->(){
          FXCanvas.new(*([pos.inst] + os.op[os.ii].to_h.values[1..-1]
                                      .map{ |v| (v.is_a?(OpenStruct) ? v.inst : v)
                         } ))
        }
        
        Enhancement.stack.pop                                                  
        @os = Enhancement.stack.last
        return os
      end
    end
  end
end
    #+end_src

    Change "axial" to "axis" to recrystalize this bug. I suspect that the parser
    or some aspect of the intepreter is confusing the "axis" function with
    the "axis" variable on the OpenStruct object, and it has to do with the
    exact way I am doing the parameters for the axis function that trips it up.
    A similar approach with the background function works perfectly fine:
    #+begin_src ruby
        def axis ax, **kv
          ap @os.axis[ax] = OpenStruct.new(**kv)
        end

        def background **kv; kv.each{ |k,v| @os.background[k] = v }; end
    #+end_src

    Which results in the error of:
    #+begin_src
    ArgumentError: wrong number of arguments (given 0, expected 1)
    from /home/alveric/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/fxruby-enhancement-0.2.0/lib/fxruby-enhancement/xtras/chart.rb:46:in `axis'
    #+end_src

    A simple workaround was to rename the variable to "axial" or anything different
    from the function "axis".

    I need to investigate if this bug also exists in prior releases of Ruby, and
    also produce a single-file scaled down example of this bug, so it can be reported
    back to Matz.

    Oh, the time...
*** JUNKYARD 'as' execution issue DEBUGGING CODE
    It is critical where the 'as' clause is executed, and we
    need to alter that, because the fx_data_target instance
    is not established at the time it's needed.

    It is thought that the execution must take place before
    kinder create_fox_components, but I need to think about this.
    It's execution time is critical to the proper flow of Enhancement.

    The following debug code allows you to specify
    not only which files to trace, but also a line
    range. And colored to. Massively useful. Maybe should
    be a gem in its own right?
    #+begin_src ruby
### debugging
TRACE_FILES = %w{
api-mapper.rb:1832-1887
enhancement.rb
scribble.rb
ostruct-monkey.rb:16-29
}

TFILES = TRACE_FILES.map{ |s| s.split(':').first }

set_trace_func proc { |event, file, line, id, binding, classname|
  base, srange = File.basename(file).split(':')
  stnum, endnum = srange.split('-') unless srange.nil?
  stnum  = srange.nil? ? nil : stnum.to_i
  endnum = srange.nil? && endnum.nil? ? nil : endnum.to_i
  if TFILES.member?(base) && (srange.nil? ||
                                  (endnum.nil? && line == stnum) ||
                                  (stnum <= line && line <= endnum))
    printf "%8s \033[32m%s:%-2d\033[0m %10s \033[33m%.50s\033[0m \033[36m%.50s\033[0m\n",
           event,
           base,            #green
           line,            #green
           id,
           classname,       #yellow
           binding.receiver #cyan
  end
}
### end debugging
    #+end_src

    It is now indeed clear that the 'as' must stick its
    kinder in the kinder list of 'as'es parent component,
    NOT the referred 'as' component itself. This is conceptually
    tricky from the code point of view, BUT it is the intuitive
    assumption from the programmer's point of view. From his
    perspective, 'as' "executes" at the place he put it.

    And so let us do the "hard" thing here to make the lives
    of our users happy. :D

    We have solution. We simply will put the kinder parent
    in a hash with the Enhancement.stack level that
    this kinder parent as opposed to the "real" parent is to be
    used. When the owner 'as' completes, it removes that entry
    from the hash.

    This will allow for nesting of 'as' declerations as well,
    with the intituively expected result. I do not recommend
    nesting 'as' declarations, but at the same time I do not
    wish to restrict our users from doing so. I simply cannot
    conceive of all the possible ways Enhancement will be 
    leveraged.

*** SCRATCHPAD FXDCWindow 
    Passing in a nil for the event is not the same
    as passing in nothing at all. Probably has to
    do with how the C interface is implemented or works.

*** JUNKYARD Thoughs on doing the layout
    As such, we have the components of the chart laid out
    as boxes linking to each other to represent their relative 
    positions to each other. As such:

    |             |               | Null Top      -0 |                |            |               |
    |             |               | Title        F-1 |                |            |               |
    |             |               | Top Ruler     -2 |                |            |               |
    | Null Left-0 | Left Ruler -2 | Graph        F-3 | Right Ruler -2 | Legend F-1 | Null Right -0 |
    |             |               | Bottom Ruler  -2 |                |            |               |
    |             |               | Caption      F-1 |                |            |               |
    |             |               | Null Bottom   -0 |                |            |               |

    And so, given the initial width and height of the
    canvas, we work to determine everything else. For
    those boxes that contain text, we know what the
    text will be, and therefore how long and tall -- minimum --
    they will need to be. And thusly we use the hints.
    
    Boxes can define their margins, and therefore, coupled
    with the float factor, determine their relationship
    with their neighors. a dominance score as shown
    in the diagram above determins how the layout will
    proceed.

    Since the chart will have the same basic layout, with
    some components enabled and disabled and like, we shall
    work our way from the outside in.

    Some boxes, like the Rulers, will take their width
    and height based on the dominate they are connected to.
    Others, like the title and caption and legend boxes,
    are floating.

    We have come up with the splendid idea of creating
    the "NullBox" -- basically the equivalent of having
    zero or the empty set. It will simplify the layout
    algorithm

    The layout algorithm shall procede as follows:
    - nil out all x,y, with, and heigts of all boxes
    - set up the NullBox with the intitals
    - work from the null box to its superiors, and so on,
      setting what can be set, leaving the rest for later.
    - when you reach the most dominant box (with no 
      superiors of its own), you should be able to fully
      determine its dimensions.
    - work back down the chain and fill in anything that's
      missing.

    For the float layout:
    - We really want to keep this simple (for now), so
      its with and height is already set by the hints.
    - for the most superior, it will have no superiors, just
      subordinates only, so its dimensions will be determined
      thusly.

    In all of this, this layout will take place everytime the application
    window is resized, so be aware of this. The computaitons shall be swift,
    just basic MDAS arithemtic. Nothing heavy-duty or fancy.

*** SCRATCHPAD FXFont Hints
    These are not documented anywhere as far as I can tell.
    I had to pull them from the FOX Toolkit source.
    #+begin_src C++
    /// Font style hints
    enum {
      Decorative     = 4,         /// Fancy fonts
      Modern         = 8,         /// Monospace typewriter font
      Roman          = 16,        /// Variable width times-like font, serif
      Script         = 32,        /// Script or cursive
      Swiss          = 64,        /// Helvetica/swiss type font, sans-serif
      System         = 128,       /// System font
      X11            = 256,       /// Raw X11 font string
      Scalable       = 512,       /// Scalable fonts
      Polymorphic    = 1024,      /// Polymorphic fonts, e.g. parametric weight, slant, etc.
      Rotatable      = 2048       /// Rotatable fonts
    };
    #+end_src

    I will wrap this -- and the other parameters -- up to make it more friendly
    for Rubyist, who should NOT have to go splunking through C++ code to 
    figure out how to do something!!!!!!!!!!!!!!

    - A sample of the string that needs to be supplied is:
      "helvetica,90,bold,italic,normal,iso8859-1,2048"
    - The format is given by the following:
        fontname
        [ "[" foundry "]" ]
        ["," size
        ["," weight
        ["," slant 
        ["," setwidth 
        ["," encoding 
        ["," hints]]]]]]

    The "entire" FXFont.h for reference is included here:
    #+begin_src C++

/*
  Notes:

  - Interpretation of the hints:

      0                    No preference for pitch
      FXFont::Fixed        If specified, match for fixed pitch fonts are strongly preferred
      FXFont::Variable     If specified, match for variable pitch font strongly preferred

      0                    No hints given
      FXFont::Decorative   Ye Olde Fonte
      FXFont::Modern       Monospace fonts such as courier and so on
      FXFont::Roman        Serif font such as times
      FXFont::Script       Cursive font/script
      FXFont::Swiss        Sans serif font such as swiss, helvetica, arial
      FXFont::System       Raster based fonts, typically monospaced

      FXFont::X11          Force X11 raw font specification

      FXFont::Scalable     Strong emphasis on scalable fonts; under Windows, this means
                           TrueType fonts are desired

      FXFont::Polymorphic  Strong emphasis on polymorphic fonts; under Windows, this means
                           TrueType fonts desired also

  - FONTENCODING_DEFAULT means we prefer the fonts for the current locale;
    currently, this is hardwired to iso8859-1 until we have some means of
    determining the preferred encoding from the locale.

  - FXFont::Italic is a cursive typeface for some fonts; FXFont::Oblique is the same
    basic font written at an angle; for many fonts, FXFont::Italic and FXFont::Oblique
    means pretty much the same thing.  When matching, FXFont::Italic and FXFont::Oblique
    are considered closer to each other than FXFont::Straight.

  - A weight value of 0 indicates preference for non-bold font.

  - XFontStruct.ascent+XFontStruct.descent is the height of the font, as far as line
    spacing goes.  XFontStruct.max_bounds.ascent+XFontStruct.max_bounds.descent is
    larger, as some characters can apparently extend beyond ascent or descent!!

  - Registry section FONTSUBSTITUTIONS can be used to map typeface names to platform
    specific typeface names:

        [FONTSUBSTITUTIONS]
        arial = helvetica
        swiss = helvetica

    This allows you to change fonts in programs with hard-wired fonts.

  - Text txfm matrix [a b c d] premultiplies.

  - Should we perhaps build our own tables of font metrics? This might make
    things simpler for the advanced stuff, and be conceivably a lot faster
    under MS-Windows [no need to SelectObject() all the time just to get some
    info; also, this could be useful in case the drawing surface is not a
    window].

  - FOR THE MOMENT we're creating a dummy DC to keep the font locked into the GDI
    for MUCH quicker access to text metrics.  Soon however we want to just build
    our own font metrics tables and determine the metrics entirely with client-side
    code.  This will [predictably] be the fastest possible method as it will not
    involve context switches...

  - Matching algorithm slightly favors bitmapped fonts over scalable ones [as the
    latter may not be optimized easthetically; also, the matching algorithm should
    not weight resolution as much.

  - UNICODE means registry and encoding are set to iso10646-1

  - More human-readable font strings (e.g. registry):

       family [foundry],size,weight,slant,setwidth,encoding,hints

    For example:

       times [urw],120,bold,i,normal,iso8859-1,0

    Note that the size is in decipoints!

  - Get encoding from locale (see X11).

*/
using namespace FX;


namespace FX {


const FXint LEAD_OFFSET=0xD800-(0x10000>>10);


// Absolute value
static inline FXint fxabs(FXint a){ return a<0?-a:a; }


#if defined(WIN32) /////////////////////////////// WIN32 ////////////////////////


// Character set encoding
static BYTE FXFontEncoding2CharSet(FXuint encoding){
  switch(encoding){
    case FONTENCODING_DEFAULT: return DEFAULT_CHARSET;
    case FONTENCODING_TURKISH: return TURKISH_CHARSET;
    case FONTENCODING_BALTIC: return BALTIC_CHARSET;
    case FONTENCODING_CYRILLIC: return RUSSIAN_CHARSET;
    case FONTENCODING_ARABIC: return ARABIC_CHARSET;
    case FONTENCODING_GREEK: return GREEK_CHARSET;
    case FONTENCODING_HEBREW: return HEBREW_CHARSET;
    case FONTENCODING_THAI: return THAI_CHARSET;
    case FONTENCODING_EASTEUROPE: return EASTEUROPE_CHARSET;
    case FONTENCODING_USASCII: return ANSI_CHARSET;
//    case FONTENCODING_UNICODE: return ANSI_CHARSET;
    }
  return DEFAULT_CHARSET;
  }


// Character set encoding
static FXuint CharSet2FXFontEncoding(BYTE lfCharSet){
  switch(lfCharSet){
    case ANSI_CHARSET: return FONTENCODING_USASCII;
    case ARABIC_CHARSET: return FONTENCODING_ARABIC;
    case BALTIC_CHARSET: return FONTENCODING_BALTIC;
    case CHINESEBIG5_CHARSET: return FONTENCODING_DEFAULT;
    case DEFAULT_CHARSET: return FONTENCODING_DEFAULT;
    case EASTEUROPE_CHARSET: return FONTENCODING_EASTEUROPE;
    case GB2312_CHARSET: return FONTENCODING_DEFAULT;
    case GREEK_CHARSET: return FONTENCODING_GREEK;
#if !defined (__WATCOMC__)
    case HANGUL_CHARSET: return FONTENCODING_DEFAULT;
#endif
    case HEBREW_CHARSET: return FONTENCODING_HEBREW;
    case MAC_CHARSET: return FONTENCODING_DEFAULT;
    case OEM_CHARSET: return FONTENCODING_DEFAULT;
    case SYMBOL_CHARSET: return FONTENCODING_DEFAULT;
    case RUSSIAN_CHARSET: return FONTENCODING_CYRILLIC;
    case SHIFTJIS_CHARSET: return FONTENCODING_DEFAULT;
    case THAI_CHARSET: return FONTENCODING_THAI;
    case TURKISH_CHARSET: return FONTENCODING_TURKISH;
    }
  return FONTENCODING_DEFAULT;
  }


void* FXFont::match(const FXString& wantfamily,const FXString& wantforge,FXuint wantsize,FXuint wantweight,FXuint wantslant,FXuint wantsetwidth,FXuint wantencoding,FXuint wanthints,FXint res){
  FXTRACE((150,"wantfamily=%s wantforge=%s wantsize=%d wantweight=%d wantslant=%d wantsetwidth=%d wantencoding=%d wanthints=%d res=%d\n",wantfamily.text(),wantforge.text(),wantsize,wantweight,wantslant,wantsetwidth,wantencoding,wanthints,res));
  TEXTMETRIC *font;
  LOGFONT lf;
  FXchar buffer[256];

  // Hang on to this for text metrics functions
  dc=CreateCompatibleDC(NULL);

  // Now fill in the fields
  lf.lfHeight=-MulDiv(wantsize,GetDeviceCaps((HDC)dc,LOGPIXELSY),720);
  lf.lfWidth=0;
  if(wanthints&FXFont::Rotatable){
    lf.lfEscapement=(angle*10)/64;
    lf.lfOrientation=(angle*10)/64;
    }
  else{
    lf.lfEscapement=0;
    lf.lfOrientation=0;
    }
  lf.lfWeight=wantweight*10;
  if((wantslant==FXFont::Italic) || (wantslant==FXFont::Oblique))
    lf.lfItalic=TRUE;
  else
    lf.lfItalic=FALSE;
  lf.lfUnderline=FALSE;
  lf.lfStrikeOut=FALSE;

  // Character set encoding
  lf.lfCharSet=FXFontEncoding2CharSet(wantencoding);

  // Other hints
  lf.lfOutPrecision=OUT_DEFAULT_PRECIS;
  if(wanthints&FXFont::System) lf.lfOutPrecision=OUT_RASTER_PRECIS;
  if(wanthints&FXFont::Scalable) lf.lfOutPrecision=OUT_TT_PRECIS;
  if(wanthints&FXFont::Polymorphic) lf.lfOutPrecision=OUT_TT_PRECIS;

  // Clip precision
  lf.lfClipPrecision=CLIP_DEFAULT_PRECIS;

  // Quality
  lf.lfQuality=DEFAULT_QUALITY;

  // Pitch and Family
  lf.lfPitchAndFamily=0;

  // Pitch
  if(wanthints&FXFont::Fixed) lf.lfPitchAndFamily|=FIXED_PITCH;
  else if(wanthints&FXFont::Variable) lf.lfPitchAndFamily|=VARIABLE_PITCH;
  else lf.lfPitchAndFamily|=DEFAULT_PITCH;

  // Family
  if(wanthints&FXFont::Decorative) lf.lfPitchAndFamily|=FF_DECORATIVE;
  else if(wanthints&FXFont::Modern) lf.lfPitchAndFamily|=FF_MODERN;
  else if(wanthints&FXFont::Roman) lf.lfPitchAndFamily|=FF_ROMAN;
  else if(wanthints&FXFont::Script) lf.lfPitchAndFamily|=FF_SCRIPT;
  else if(wanthints&FXFont::Swiss) lf.lfPitchAndFamily|=FF_SWISS;
  else lf.lfPitchAndFamily|=FF_DONTCARE;

  // Font substitution
#ifdef UNICODE
  utf2ncs(lf.lfFaceName,wantfamily.text(),wantfamily.length()+1);
#else
  strncpy(lf.lfFaceName,wantfamily.text(),sizeof(lf.lfFaceName));
#endif

  // Here we go!
  xid=CreateFontIndirect(&lf);

  // Uh-oh, we failed
  if(!xid) return NULL;

  // Obtain text metrics
  if(!FXCALLOC(&font,TEXTMETRIC,1)) return NULL;

  SelectObject((HDC)dc,xid);
  GetTextMetrics((HDC)dc,(TEXTMETRIC*)font);

  // Get actual face name
  GetTextFaceA((HDC)dc,sizeof(buffer),buffer);
  actualName=buffer;
  actualSize=MulDiv(((TEXTMETRIC*)font)->tmHeight,720,GetDeviceCaps((HDC)dc,LOGPIXELSY)); // FIXME no cigar yet?
  actualWeight=((TEXTMETRIC*)font)->tmWeight/10;
  actualSlant=((TEXTMETRIC*)font)->tmItalic?FXFont::Italic:FXFont::Straight;
  actualSetwidth=0;
  actualEncoding=CharSet2FXFontEncoding(((TEXTMETRIC*)font)->tmCharSet);

  // Return it
  return font;
  }


// Yuk. Need to get some data into the callback function.
struct FXFontStore {
  HDC         hdc;
  FXFontDesc *fonts;
  FXuint      numfonts;
  FXuint      size;
  FXFontDesc  desc;
  };


// Callback function for EnumFontFamiliesEx()
static int CALLBACK EnumFontFamExProc(const LOGFONTA *lf,const TEXTMETRICA *lptm,DWORD FontType,LPARAM lParam){
  register FXFontStore *pFontStore=(FXFontStore*)lParam;
  FXASSERT(lf);
  FXASSERT(lptm);
  FXASSERT(pFontStore);

  // Get pitch
  FXuint flags=0;
  if(lf->lfPitchAndFamily&FIXED_PITCH) flags|=FXFont::Fixed;
  if(lf->lfPitchAndFamily&VARIABLE_PITCH) flags|=FXFont::Variable;

  // Get hints
  if(lf->lfPitchAndFamily&FF_DONTCARE) flags|=0;
  if(lf->lfPitchAndFamily&FF_MODERN) flags|=FXFont::Modern;
  if(lf->lfPitchAndFamily&FF_ROMAN) flags|=FXFont::Roman;
  if(lf->lfPitchAndFamily&FF_SCRIPT) flags|=FXFont::Script;
  if(lf->lfPitchAndFamily&FF_DECORATIVE) flags|=FXFont::Decorative;
  if(lf->lfPitchAndFamily&FF_SWISS) flags|=FXFont::Swiss;

  // Skip if no match
  FXuint h=pFontStore->desc.flags;
  if((h&FXFont::Fixed) && !(flags&FXFont::Fixed)) return 1;
  if((h&FXFont::Variable) && !(flags&FXFont::Variable)) return 1;

  // Get weight (also guess from the name)
  FXuint weight=lf->lfWeight/10;
  if(strstr(lf->lfFaceName,"Bold")!=NULL) weight=FXFont::Bold;
  if(strstr(lf->lfFaceName,"Black")!=NULL) weight=FXFont::Black;
  if(strstr(lf->lfFaceName,"Demi")!=NULL) weight=FXFont::DemiBold;
  if(strstr(lf->lfFaceName,"Light")!=NULL) weight=FXFont::Light;
  if(strstr(lf->lfFaceName,"Medium")!=NULL) weight=FXFont::Medium;

  // Skip if weight doesn't match
  FXuint wt=pFontStore->desc.weight;
  if((wt!=0) && (wt!=weight)) return 1;

  // Get slant
  FXuint slant=FXFont::Straight;
  if(lf->lfItalic==TRUE) slant=FXFont::Italic;
  if(strstr(lf->lfFaceName,"Italic")!=NULL) slant=FXFont::Italic;
  if(strstr(lf->lfFaceName,"Roman")!=NULL) slant=FXFont::Straight;

  // Skip if no match
  FXuint sl=pFontStore->desc.slant;
  if((sl!=0) && (sl!=slant)) return 1;

  // Get set width (also guess from the name)
  FXuint setwidth=0;
  if(strstr(lf->lfFaceName,"Cond")!=NULL) setwidth=FXFont::Condensed;
  if(strstr(lf->lfFaceName,"Narrow")!=NULL) setwidth=FXFont::Condensed;
  if(strstr(lf->lfFaceName,"Ext Cond")!=NULL) setwidth=FXFont::ExtraCondensed;

  // Skip if no match
  FXuint sw=pFontStore->desc.setwidth;
  if((sw!=0) && (sw!=setwidth)) return 1;

  // Get encoding
  FXuint encoding=CharSet2FXFontEncoding(lf->lfCharSet);

  // Skip if no match
  FXuint en=pFontStore->desc.encoding;
  if((en!=FONTENCODING_DEFAULT) && (en!=encoding)) return 1;

  // Is it scalable?
  if(FontType==TRUETYPE_FONTTYPE){
    flags|=FXFont::Scalable;
    }

  // Is it polymorphic?
  if(FontType==TRUETYPE_FONTTYPE){
    flags|=FXFont::Polymorphic;
    }

  // Initial allocation of storage?
  if(pFontStore->numfonts==0){
    FXMALLOC(&pFontStore->fonts,FXFontDesc,50);
    if(pFontStore->fonts==0) return 0;
    pFontStore->size=50;
    }

  // Grow the array if needed
  if(pFontStore->numfonts>=pFontStore->size){
    FXRESIZE(&pFontStore->fonts,FXFontDesc,pFontStore->size+50);
    if(pFontStore->fonts==0) return 0;
    pFontStore->size+=50;
    }

  FXFontDesc *fonts=pFontStore->fonts;
  FXuint numfonts=pFontStore->numfonts;

  strncpy(fonts[numfonts].face,lf->lfFaceName,116);
  if(lf->lfHeight<0){
    fonts[numfonts].size=-MulDiv(lf->lfHeight,720,GetDeviceCaps(pFontStore->hdc,LOGPIXELSY));
    }
  else{
    fonts[numfonts].size=MulDiv(lf->lfHeight,720,GetDeviceCaps(pFontStore->hdc,LOGPIXELSY));
    }
  fonts[numfonts].weight=weight;
  fonts[numfonts].slant=slant;
  fonts[numfonts].encoding=encoding;
  fonts[numfonts].setwidth=setwidth;
  fonts[numfonts].flags=flags;

  pFontStore->fonts=fonts;
  pFontStore->numfonts++;

  // Must return 1 to continue enumerating fonts
  return 1;
  }


#elif defined(HAVE_XFT_H) /////////////////////// XFT ///////////////////////////


// Access to display
#define DISPLAY(app)      ((Display*)((app)->display))


// From FOX weight to fontconfig weight
static FXint weight2FcWeight(FXint weight){
  switch(weight){
    case FXFont::Thin:      return FC_WEIGHT_THIN;
    case FXFont::ExtraLight:return FC_WEIGHT_EXTRALIGHT;
    case FXFont::Light:     return FC_WEIGHT_LIGHT;
    case FXFont::Normal:    return FC_WEIGHT_NORMAL;
    case FXFont::Medium:    return FC_WEIGHT_MEDIUM;
    case FXFont::DemiBold:  return FC_WEIGHT_DEMIBOLD;
    case FXFont::Bold:      return FC_WEIGHT_BOLD;
    case FXFont::ExtraBold: return FC_WEIGHT_EXTRABOLD;
    case FXFont::Black:     return FC_WEIGHT_BLACK;
    }
  return FC_WEIGHT_NORMAL;
  }


// From fontconfig weight to FOX weight
static FXint fcWeight2Weight(FXint fcWeight){
  switch(fcWeight){
    case FC_WEIGHT_THIN:      return FXFont::Thin;
    case FC_WEIGHT_EXTRALIGHT:return FXFont::ExtraLight;
    case FC_WEIGHT_LIGHT:     return FXFont::Light;
    case FC_WEIGHT_NORMAL:    return FXFont::Normal;
    case FC_WEIGHT_MEDIUM:    return FXFont::Medium;
    case FC_WEIGHT_DEMIBOLD:  return FXFont::DemiBold;
    case FC_WEIGHT_BOLD:      return FXFont::Bold;
    case FC_WEIGHT_EXTRABOLD: return FXFont::ExtraBold;
    case FC_WEIGHT_BLACK:     return FXFont::Black;
    }
  return FXFont::Normal;
  }


// From FOX setwidth to fontconfig setwidth
static FXint setWidth2FcSetWidth(FXint setwidth){
  switch(setwidth){
    case FXFont::UltraCondensed:return FC_WIDTH_ULTRACONDENSED;
    case FXFont::ExtraCondensed:return FC_WIDTH_EXTRACONDENSED;
    case FXFont::Condensed:     return FC_WIDTH_CONDENSED;
    case FXFont::SemiCondensed: return FC_WIDTH_SEMICONDENSED;
    case FXFont::NonExpanded:        return FC_WIDTH_NORMAL;
    case FXFont::SemiExpanded:  return FC_WIDTH_SEMIEXPANDED;
    case FXFont::Expanded:      return FC_WIDTH_EXPANDED;
    case FXFont::ExtraExpanded: return FC_WIDTH_EXTRAEXPANDED;
    case FXFont::UltraExpanded: return FC_WIDTH_ULTRAEXPANDED;
    }
  return FC_WIDTH_NORMAL;
  }


// From fontconfig setwidth to FOX setwidth
static FXint fcSetWidth2SetWidth(FXint fcSetWidth){
  switch(fcSetWidth){
    case FC_WIDTH_ULTRACONDENSED:return FXFont::UltraCondensed;
    case FC_WIDTH_EXTRACONDENSED:return FXFont::ExtraCondensed;
    case FC_WIDTH_CONDENSED:     return FXFont::Condensed;
    case FC_WIDTH_SEMICONDENSED: return FXFont::SemiCondensed;
    case FC_WIDTH_NORMAL:        return FXFont::NonExpanded;
    case FC_WIDTH_SEMIEXPANDED:  return FXFont::SemiExpanded;
    case FC_WIDTH_EXPANDED:      return FXFont::Expanded;
    case FC_WIDTH_EXTRAEXPANDED: return FXFont::ExtraExpanded;
    case FC_WIDTH_ULTRAEXPANDED: return FXFont::UltraExpanded;
    }
  return FXFont::NonExpanded;
  }


// From FOX slant to fontconfig slant
static FXint slant2FcSlant(FXint slant){
  switch(slant){
    case FXFont::Straight: return FC_SLANT_ROMAN;
    case FXFont::Italic: return FC_SLANT_ITALIC;
    case FXFont::Oblique: return FC_SLANT_OBLIQUE;
    case FXFont::ReverseItalic: return FC_SLANT_ITALIC;         // No equivalent FC value
    case FXFont::ReverseOblique: return FC_SLANT_OBLIQUE;       // No equivalent FC value
    }
  return FC_SLANT_ROMAN;
  }


// From fontconfig slant to FOX slant
static FXint fcSlant2Slant(FXint fcSlant){
  switch(fcSlant){
    case FC_SLANT_ROMAN:  return FXFont::Straight;
    case FC_SLANT_ITALIC: return FXFont::Italic;
    case FC_SLANT_OBLIQUE:return FXFont::Oblique;
    }
  return FXFont::Straight;
  }


// Try find matching font
void* FXFont::match(const FXString& wantfamily,const FXString& wantforge,FXuint wantsize,FXuint wantweight,FXuint wantslant,FXuint wantsetwidth,FXuint wantencoding,FXuint wanthints,FXint res){
  int        pp,sw,wt,sl;
  double     a,s,c,sz;
  FcPattern *pattern,*p;
  FcChar8   *fam,*fdy;
  FcCharSet *charset;
  XftFont   *font;
  FcResult   result;
  FcBool     sc;
  FcMatrix   matrix;

  FXTRACE((150,"wantfamily=%s wantforge=%s wantsize=%d wantweight=%d wantslant=%d wantsetwidth=%d wantencoding=%d wanthints=%d res=%d\n",wantfamily.text(),wantforge.text(),wantsize,wantweight,wantslant,wantsetwidth,wantencoding,wanthints,res));

  // Create pattern object
  pattern=FcPatternCreate();

  // Set family
  if(!wantfamily.empty()){
    FcPatternAddString(pattern,FC_FAMILY,(const FcChar8*)wantfamily.text());
    }

  // Set foundry
  if(!wantforge.empty()){
    FcPatternAddString(pattern,FC_FOUNDRY,(const FcChar8*)wantforge.text());
    }

  // Set pixel size, based on given screen res and desired point size
  if(wantsize!=0){
    FcPatternAddDouble(pattern,FC_PIXEL_SIZE,(res*wantsize)/720.0);
    }

  // Set font weight
  if(wantweight!=0){
    FcPatternAddInteger(pattern,FC_WEIGHT,weight2FcWeight(wantweight));
    }

  // Set slant
  if(wantslant!=0){
    FcPatternAddInteger(pattern,FC_SLANT,slant2FcSlant(wantslant));
    }

  // Set setwidth
  if(wantsetwidth!=0){
    FcPatternAddInteger(pattern,FC_WIDTH,setWidth2FcSetWidth(wantsetwidth));
    }

  // Set encoding
  if(wantencoding!=FONTENCODING_DEFAULT){                                       // FIXME
//    FcCharSet* charSet=FcCharSetCreate();
//    encoding2FcCharSet((void*)charSet, (FXFontEncoding)encoding);
//    FcPatternAddCharSet(pattern, FC_CHARSET, charSet);
//    FcCharSetDestroy(charSet);
    }

  // Set pitch
  if(wanthints&FXFont::Fixed){
    FcPatternAddInteger(pattern,FC_SPACING,FC_MONO);
    }
  else if(wanthints&FXFont::Variable){
    FcPatternAddInteger(pattern,FC_SPACING,FC_PROPORTIONAL);
    }

  // Scalable font hint; also set if we want rotation
  if(wanthints&(FXFont::Scalable|FXFont::Rotatable)){
    FcPatternAddBool(pattern,FC_SCALABLE,TRUE);
    }

  // Always set matrix if rotatable
  if(wanthints&FXFont::Rotatable){
    a=0.00027270769562411399179*angle;
    c=cos(a);
    s=sin(a);
    matrix.xx=c; matrix.xy=-s;
    matrix.yx=s; matrix.yy=c;
    FcPatternAddMatrix(pattern,FC_MATRIX,&matrix);
    }

  // Pattern substitutions
  FcConfigSubstitute(0,pattern,FcMatchPattern);
  FcDefaultSubstitute(pattern);

  // Find pattern matching a font
  p=FcFontMatch(0,pattern,&result);
  if(!p) return NULL;

  // Get name and foundry
  if(FcPatternGetString(p,FC_FAMILY,0,&fam)==FcResultMatch){
    actualName=(const FXchar*)fam;
    if(FcPatternGetString(p,FC_FOUNDRY,0,&fdy)==FcResultMatch){
      actualName.append(" [");
      actualName.append((const FXchar*)fdy);
      actualName.append("]");
      }
    }

  // Get setwidth
  if(FcPatternGetInteger(p,FC_WIDTH,0,&sw)==FcResultMatch){
    actualSetwidth=fcSetWidth2SetWidth(sw);
    }

  // Get weight
  if(FcPatternGetInteger(p,FC_WEIGHT,0,&wt)==FcResultMatch){
    actualWeight=fcWeight2Weight(wt);
    }

  // Get slant
  if(FcPatternGetInteger(p,FC_SLANT,0,&sl)==FcResultMatch){
    actualSlant=fcSlant2Slant(sl);
    }

  // Get pitch
  if(FcPatternGetInteger(p,FC_SPACING,0,&pp)==FcResultMatch){
    flags&=~(FXFont::Fixed|FXFont::Variable);
//    if(pp==FC_MONO || pp==FC_DUAL || pp==FC_CHARCELL) flags|=FXFont::Fixed;
    if(pp==FC_MONO || pp==FC_CHARCELL) flags|=FXFont::Fixed;
    else if(pp==FC_PROPORTIONAL) flags|=FXFont::Variable;
    }

  // Get scalable flag
  if(FcPatternGetBool(p,FC_SCALABLE,0,&sc)==FcResultMatch){
    flags=sc?(flags|FXFont::Scalable):(flags&~FXFont::Scalable);
    }

  // Get pixel size and work it back to deci-points using given screen res
  if(FcPatternGetDouble(p,FC_PIXEL_SIZE,0,&sz)==FcResultMatch){
    actualSize=(int)((720.0*sz)/res);
    }

  // Get charset
  if(FcPatternGetCharSet(p,FC_CHARSET,0,&charset)==FcResultMatch){      // FIXME
    }

  // Get the encoding
  actualEncoding=FONTENCODING_UNICODE;

  // Open font
  font=XftFontOpenPattern(DISPLAY(getApp()),p);
  xid=(FXID)font;

  // Destroy pattern
  FcPatternDestroy(pattern);

  return font;
  }


#else ///////////////////////////////// XLFD ////////////////////////////////////


#define SGN(x)        ((x)<0.0?"~":"")
#define DISPLAY(app)  ((Display*)((app)->display))


// Convert text to font weight
static FXuint xlfdWeight(const FXchar* text){
  register FXchar c1=Ascii::toLower(text[0]);
  register FXchar c2=Ascii::toLower(text[1]);
  if(c1=='l' && c2=='i') return FXFont::Light;
  if(c1=='o' && c2=='u') return FXFont::Light;
  if(c1=='s' && c2=='h') return FXFont::Light;
  if(c1=='n' && c2=='o') return FXFont::Normal;
  if(c1=='r' && c2=='e') return FXFont::Normal;
  if(c1=='m' && c2=='e') return FXFont::Medium;
  if(c1=='d' && c2=='e') return FXFont::DemiBold;
  if(c1=='s' && c2=='e') return FXFont::DemiBold;
  if(c1=='b' && c2=='o') return FXFont::Bold;
  if(c1=='b' && c2=='l') return FXFont::Black;
  return 0;
  }


// Convert text to slant
static FXuint xlfdSlant(const FXchar* text){
  register FXchar c1=Ascii::toLower(text[0]);
  register FXchar c2=Ascii::toLower(text[1]);
  if(c1=='i') return FXFont::Italic;
  if(c1=='o') return FXFont::Oblique;
  if(c1=='r' && c2=='i') return FXFont::ReverseItalic;
  if(c1=='r' && c2=='o') return FXFont::ReverseOblique;
  if(c1=='r') return FXFont::Straight;
  return 0;
  }


// Convert text to setwidth
static FXuint xlfdSetwidth(const FXchar* text){
  if(text[0]=='m') return FXFont::NonExpanded;
  if(text[0]=='w') return FXFont::ExtraExpanded;
  if(text[0]=='r') return FXFont::NonExpanded;
  if(text[0]=='c') return FXFont::Condensed;
  if(text[0]=='n'){
    if(text[1]=='a') return FXFont::Condensed;
    if(text[1]=='o') return FXFont::NonExpanded;
    return 0;
    }
  if(text[0]=='e' && text[1]=='x' && text[2]=='p') return FXFont::Expanded;
  if(text[0]=='e' && text[1]=='x' && text[2]=='t' && text[3]=='r' && text[4]=='a'){
    if(text[5]=='c') return FXFont::ExtraCondensed;
    if(text[5]=='e') return FXFont::ExtraExpanded;
    return 0;
    }
  if(text[0]=='u' && text[1]=='l' && text[2]=='t' && text[3]=='r' && text[4]=='a'){
    if(text[5]=='c') return FXFont::UltraCondensed;
    if(text[5]=='e') return FXFont::UltraExpanded;
    return 0;
    }
  if((text[0]=='s' || text[0]=='d') && text[1]=='e' && text[2]=='m' && text[3]=='i'){
    if(text[5]=='c') return FXFont::SemiCondensed;
    if(text[5]=='e') return FXFont::SemiExpanded;
    return 0;
    }
  return 0;
  }


// Convert pitch to flags
static FXuint xlfdPitch(const FXchar* text){
  register FXchar c=Ascii::toLower(text[0]);
  if(c=='p') return FXFont::Variable;
  if(c=='m' || c=='c') return FXFont::Fixed;
  return 0;
  }


// Convert fields to scalable flag
static FXuint xlfdScalable(const FXchar *pixelsize,const FXchar *pointsize,const FXchar* average){
  if(pixelsize[0]=='[' && pointsize[0]=='[' && average[0]=='0') return FXFont::Scalable;
  if(pixelsize[0]=='0' && pointsize[0]=='0' && average[0]=='0') return FXFont::Scalable;
  return 0;
  }


// Convert fields to rotatable flag
static FXuint xlfdRotatable(const FXchar *pixelsize,const FXchar *pointsize){
  if(pixelsize[0]=='[' && pointsize[0]=='[') return FXFont::Rotatable;
  return 0;
  }


// Convert fields to rotatable flag
static FXuint xlfdPolymorph(const FXchar *weight,const FXchar* slant,const FXchar *setwidth,const FXchar* addstyle){
  if(weight[0]=='0' || slant[0]=='0' || setwidth[0]=='0' || addstyle[0]=='0') return FXFont::Polymorphic;
  return 0;
  }


// Determine encoding; these codes should tie into the codec list in some way
static FXuint xlfdEncoding(const FXchar* text){
  if((text[0]=='i' || text[0]=='I') && (text[1]=='s' || text[1]=='S') && (text[2]=='o' || text[2]=='O')){
    if(text[3]=='8' && text[4]=='8' && text[5]=='5' && text[6]=='9' && text[7]=='-'){
      return FONTENCODING_ISO_8859_1+atoi(text+8)-1;    // iso8859-XX
      }
    if(text[3]=='1' && text[4]=='0' &&text[5]=='6' && text[6]=='4' && text[7]=='6' && text[8]=='-' && text[9]=='1'){
      return FONTENCODING_UNICODE;                      // iso10646-1
      }
    return FONTENCODING_DEFAULT;
    }
  if((text[0]=='k' || text[0]=='K') && (text[1]=='o' || text[1]=='O') && (text[2]=='i' || text[2]=='I') && text[3]=='8'){
    if(text[4]=='r' || text[4]=='R'){
      return FONTENCODING_KOI8_R;                       // koi8r
      }
    if(text[4]=='u' || text[4]=='U'){                   // koi8u
      return FONTENCODING_KOI8_U;
      }
    return FONTENCODING_KOI8;
    }
  if((text[0]=='m' || text[0]=='M') && (text[1]=='i' || text[1]=='I') && (text[2]=='c' || text[2]=='C') && (text[3]=='r' || text[3]=='R') && (text[4]=='o' || text[4]=='O') && (text[5]=='s' || text[5]=='S') && (text[6]=='o' || text[6]=='O') && (text[7]=='f' || text[7]=='F') && (text[8]=='t' || text[8]=='T') && text[9]=='-'){
    if((text[10]=='c' || text[10]=='C') && (text[11]=='p' || text[11]=='P')){
      return atoi(text+12);                             // microsoft-cpXXXX
      }
    return FONTENCODING_DEFAULT;
    }
  if((text[0]=='j' || text[0]=='J') && (text[1]=='i' || text[1]=='I') && (text[2]=='s' || text[2]=='S') && (text[3]=='x' || text[3]=='X')){
    return FONTENCODING_DEFAULT;                        // jisx.XXXX.YYYY-Z FIXME
    }
  if((text[0]=='b' || text[0]=='B') && (text[1]=='i' || text[1]=='I') && (text[2]=='g' || text[2]=='G') && text[3]=='5'){
    return FONTENCODING_DEFAULT;                        // big5XXX FIXME
    }
  if((text[0]=='k' || text[0]=='K') && (text[1]=='s' || text[1]=='S') && (text[2]=='c' || text[2]=='C')){
    return FONTENCODING_DEFAULT;                        // kscXXX FIXME
    }
  if((text[0]=='g' || text[0]=='G') && (text[1]=='b' || text[1]=='B')){
    return FONTENCODING_DEFAULT;                        // gbXXXX FIXME
    }
  return FONTENCODING_DEFAULT;
  }


// Split XLFD into pieces
static int xlfdSplit(char *fld[],char* font){
  fld[0]=fld[2]=fld[3]=fld[4]=fld[5]=fld[6]=fld[7]=fld[8]=fld[9]=fld[10]=fld[11]=fld[12]="";
  fld[1]=font;
  if(*font++=='-'){
    fld[0]=font;
    for(int f=1; f<=12; f++){
      while(*font && *font!='-') font++;
      if(*font=='-') *font++='\0';
      fld[f]=font;
      }
    }
  return 1;
  }


// Return font name from a font possibly containing wildcards
static FXString xlfdFont(Display *dpy,const FXString& font){
  char **fontnames; int nfontnames;
  FXString fontname(font);
  if((fontnames=XListFonts(dpy,font.text(),1,&nfontnames))!=NULL){
    fontname=fontnames[0];
    XFreeFontNames(fontnames);
    }
  return fontname;
  }


// Try find matching font
void* FXFont::match(const FXString& wantfamily,const FXString& wantforge,FXuint wantsize,FXuint wantweight,FXuint wantslant,FXuint wantsetwidth,FXuint wantencoding,FXuint wanthints,FXint res){
  FXuint   encoding,weight,slant,setwidth,pitch,scalable,rotatable,polymorph,xres,yres,points,size;
  FXint    bencoding,bweight,bslant,bsetwidth,bpitch,bscalable,brotatable,bpolymorph,bsize,bxres,byres;
  FXint    dencoding,dweight,dslant,dsetwidth,dpitch,dscalable,drotatable,dpolymorph,dsize;
  FXchar   candidate[256],xlfd[256];
  FXchar  *field[13];
  FXchar **fontnames;
  FXint    nfontnames,b,f;
  FXdouble c,s,a;
  XFontStruct *font;

  FXTRACE((150,"wantfamily=%s wantforge=%s wantsize=%d wantweight=%d wantslant=%d wantsetwidth=%d wantencoding=%d wanthints=%d res=%d\n",wantfamily.text(),wantforge.text(),wantsize,wantweight,wantslant,wantsetwidth,wantencoding,wanthints,res));

  // Get fonts matching the pattern
  sprintf(candidate,"-%s-%s-*-*-*-*-*-%s-*-*-*-*-*-*",wantforge.empty()?"*":wantforge.text(),wantfamily.empty()?"*":wantfamily.text(),(hints&FXFont::Rotatable)?"[1 0 0 1]":"*");
  fontnames=XListFonts(DISPLAY(getApp()),candidate,65535,&nfontnames);
  if(fontnames && 0<nfontnames){

    b=-1;
    bencoding=100000;
    bweight=100000;
    bslant=100000;
    bsetwidth=100000;
    bpitch=100000;
    bscalable=100000;
    brotatable=100000;
    bpolymorph=100000;
    bsize=100000;
    bxres=res;
    byres=res;

    // Match them
    for(f=0; f<nfontnames; f++){

      //FXTRACE((100,"font=%s\n",fontnames[f]));

      // Break apart into fields
      strncpy(candidate,fontnames[f],sizeof(candidate));
      xlfdSplit(field,candidate);

      // Get info
      weight=xlfdWeight(field[2]);
      slant=xlfdSlant(field[3]);
      setwidth=xlfdSetwidth(field[4]);
      scalable=xlfdScalable(field[6],field[7],field[11]);
      polymorph=xlfdPolymorph(field[2],field[3],field[4],field[5]);
      rotatable=xlfdRotatable(field[6],field[7]);
      points=atoi(field[7]);    // Deci-points
      xres=atoi(field[8]);
      yres=atoi(field[9]);
      pitch=xlfdPitch(field[10]);
      encoding=xlfdEncoding(field[12]);

      // The font can be rendered at any resolution, so render at actual device resolution
      if(xres==0 && yres==0){
        xres=res;
        yres=res;
        }

      // Encoding
      if(wantencoding==FONTENCODING_DEFAULT){
        dencoding=(encoding!=FONTENCODING_ISO_8859_1);
        }
      else{
        dencoding=(encoding!=wantencoding);
        }

      // Weight
      if(wantweight){
        dweight=fxabs(weight-wantweight);
        }
      else{
        dweight=fxabs(weight-FXFont::Normal);
        }

      // Slant
      if(wantslant){
        dslant=fxabs(slant-wantslant);
        }
      else{
        dslant=fxabs(slant-FXFont::Straight);
        }

      // Set width
      if(wantsetwidth){
        dsetwidth=fxabs(setwidth-wantsetwidth);
        }
      else{
        dsetwidth=fxabs(setwidth-FXFont::NonExpanded);
        }

      // Pitch
      if(wanthints&FXFont::Fixed){
        dpitch=(FXFont::Fixed!=pitch);
        }
      else if(wanthints&FXFont::Variable){
        dpitch=(FXFont::Variable!=pitch);
        }
      else{
        dpitch=0;
        }

      // Scalable
      if(wanthints&FXFont::Scalable){
        dscalable=(FXFont::Scalable!=scalable);
        }
      else{
        dscalable=0;
        }

      // Rotatable
      if(wanthints&FXFont::Rotatable){
        drotatable=(FXFont::Rotatable!=rotatable);
        }
      else{
        drotatable=0;
        }

      // Polymorphic
      if(wanthints&FXFont::Polymorphic){
        dpolymorph=(FXFont::Polymorphic!=polymorph);
        }
      else{
        dpolymorph=0;
        }

      // If scalable, we can of course get the exact size we want
      // We do not set dsize to 0, as we prefer a bitmapped font that gets within
      // 10% over a scalable one that's exact, as the bitmapped fonts look much better
      // at small sizes than scalable ones...
      if(scalable){
        dsize=wantsize/10;
        size=wantsize;
        }

      // We correct for the actual screen resolution; if the font is rendered at a
      // 100 dpi, and we have a screen with 90dpi, the actual point size of the font
      // should be multiplied by (100/90).
      else{
        size=(yres*points)/res;
        dsize=fxabs(size-wantsize);
        }

      FXTRACE((160,"%4d: dweight=%-3d dsize=%3d dslant=%d dsetwidth=%d dscalable=%d dpolymorph=%d xres=%-3d yres=%-3d xlfd=\"%s\"\n",f,dweight,dsize,dslant,dsetwidth,dscalable,dpolymorph,xres,yres,fontnames[f]));

      // But I'm NOT drinking any fucking Merlot!
      if((dencoding<bencoding) || ((dencoding==bencoding) && ((drotatable<brotatable) || ((drotatable==brotatable) && ((dpitch<bpitch) || ((dpitch==bpitch) && ((dsize<bsize) || ((dsize==bsize) && ((dweight<bweight) || ((dweight==bweight) && ((dslant<bslant) || ((dslant==bslant) && ((dsetwidth<bsetwidth) || ((dsetwidth==bsetwidth) && ((dscalable<bscalable) || ((dscalable==bscalable) && (dpolymorph<bpolymorph))))))))))))))))){

        // Best match
        actualName=field[1];
        actualName.append(" [");
        actualName.append(field[0]);
        actualName.append("]");
        actualSize=size;
        actualWeight=weight;
        actualSlant=slant;
        actualSetwidth=setwidth;
        actualEncoding=encoding;
        flags=pitch|scalable|polymorph|rotatable;

        // Closeness
        bencoding=dencoding;
        brotatable=drotatable;
        bpitch=dpitch;
        bsize=dsize;
        bweight=dweight;
        bslant=dslant;
        bsetwidth=dsetwidth;
        bscalable=dscalable;
        bpolymorph=dpolymorph;
        bxres=xres;
        byres=yres;
        b=f;
        }
      }

    // Got a font?
    if(0<=b){

      FXTRACE((150,"bweight=%-3d bsize=%3d bslant=%d bsetwidth=%d bscalable=%d bpolymorph=%d bxres=%-3d byres=%-3d xlfd=\"%s\"\n",bweight,bsize,bslant,bsetwidth,bscalable,bpolymorph,bxres,byres,fontnames[b]));

      // Keep desired font name
      strncpy(xlfd,fontnames[b],sizeof(xlfd));

      // Free the list
      XFreeFontNames(fontnames);

/*
      // If font is scaled or rotated, build custom xlfd
      if(flags&(FXFont::Scalable|FXFont::Rotatable)){

        // Bust up XLFD into parts
        strncpy(candidate,xlfd,sizeof(candidate));
        xlfdSplit(field,candidate);

        // Create rotated font
        if(flags&FXFont::Rotatable){
          a=0.00027270769562411399179*angle;
          c=(cos(a)*res*actualSize)/(10.0*byres);
          s=(sin(a)*res*actualSize)/(10.0*byres);
          sprintf(xlfd,"-%s-%s-%s-%s-%s-%s-*-[%s%.3f %s%.3f %s%.3f %s%.3f]-%d-%d-%s-*-%s",field[0],field[1],field[2],field[3],field[4],field[5],SGN(c),fabs(c),SGN(s),fabs(s),SGN(-s),fabs(s),SGN(c),fabs(c),bxres,byres,field[10],field[12]);
          }

        // Create scaled font
        else{
          sprintf(xlfd,"-%s-%s-%s-%s-%s-%s-*-%d-%d-%d-%s-*-%s",field[0],field[1],field[2],field[3],field[4],field[5],(res*actualSize)/byres,bxres,byres,field[10],field[12]);
          }
        }

      // Try load it
      font=XLoadQueryFont(DISPLAY(getApp()),xlfd);
*/

      // If font is scaled or rotated, build custom xlfd
      if(flags&(FXFont::Scalable|FXFont::Rotatable)){

        // Bust up XLFD into parts
        strncpy(candidate,xlfd,sizeof(candidate));
        xlfdSplit(field,candidate);

        // Create scaled font
        sprintf(xlfd,"-%s-%s-%s-%s-%s-%s-*-%d-%d-%d-%s-*-%s",field[0],field[1],field[2],field[3],field[4],field[5],(res*actualSize)/byres,bxres,byres,field[10],field[12]);

        // Load normal scaled font
        font=XLoadQueryFont(DISPLAY(getApp()),xlfd);

        // This is an ugly workaround:- according to docs, the X11 server is supposed to
        // fill XCharStruct's in the XFontStruct such that the attribute data represents
        // the escapement amount; however, this appears to be total garbage for all but a
        // few of the installed fonts; moreover, the width member of the XCharStruct is
        // also total garbage for these rotated fonts.
        // The fix here is very tricky, but it works:- first, we grab the normal horizontal
        // font's XFontStruct using XLoadQueryFont().  Then, we XUnloadFont() the font while
        // keeping the XFontStruct.  Next, we load the rotated font using XLoadFont() and
        // plug the font id into the XFontStruct.  This works, since while the XCharStruct's
        // may sometimes be located in read-only shared memory, the XFontStruct is always
        // allocated in the client by Xlib.
        if(font && (flags&FXFont::Rotatable)){
          a=0.00027270769562411399179*angle;
          c=(cos(a)*res*actualSize)/(10.0*byres);
          s=(sin(a)*res*actualSize)/(10.0*byres);
          sprintf(xlfd,"-%s-%s-%s-%s-%s-%s-*-[%s%.3f %s%.3f %s%.3f %s%.3f]-%d-%d-%s-*-%s",field[0],field[1],field[2],field[3],field[4],field[5],SGN(c),fabs(c),SGN(s),fabs(s),SGN(-s),fabs(s),SGN(c),fabs(c),bxres,byres,field[10],field[12]);
          XUnloadFont(DISPLAY(getApp()),((XFontStruct*)font)->fid);
          ((XFontStruct*)font)->fid=XLoadFont(DISPLAY(getApp()),xlfd);
          }
        }

      // Simple case for horizontally drawn fonts
      else{
        font=XLoadQueryFont(DISPLAY(getApp()),xlfd);
        }

/*
      if(font){
        for(b=0; b<((XFontStruct*)font)->n_properties; b++){
          if(((XFontStruct*)font)->properties[b].name==XA_FONT){
            char *fn=XGetAtomName(DISPLAY(getApp()),((XFontStruct*)font)->properties[b].card32);
            strncpy(candidate,fn,sizeof(candidate));
            FXTRACE((100,"FONT = %s\n",candidate));
            xlfdSplit(field,candidate);
            XFree(fn);
            FXTRACE((100,"mat  = %s\n",field[6]));
            }
          else{
            FXTRACE((100,"%d (%s) = %d\n",((XFontStruct*)font)->properties[b].name,XGetAtomName(DISPLAY(getApp()),((XFontStruct*)font)->properties[b].name),((XFontStruct*)font)->properties[b].card32));
            }
          }
        }
*/
      return font;
      }
    }
  return NULL;
  }


#endif //////////////////////////////////////////////////////////////////////////


/*******************************************************************************/

// Object implementation
FXIMPLEMENT(FXFont,FXId,NULL,0)


// Deserialization
FXFont::FXFont(){
  wantedSize=0;
  actualSize=0;
  wantedWeight=0;
  actualWeight=0;
  wantedSlant=0;
  actualSlant=0;
  wantedSetwidth=0;
  actualSetwidth=0;
  wantedEncoding=0;
  actualEncoding=0;
  hints=0;
  flags=0;
  angle=0;
  font=NULL;
#ifdef WIN32
  dc=NULL;
#endif
  }


// Construct font from given font description
FXFont::FXFont(FXApp* a,const FXString& string):FXId(a){
  FXTRACE((100,"FXFont::FXFont %p\n",this));
  wantedSize=0;
  actualSize=0;
  wantedWeight=0;
  actualWeight=0;
  wantedSlant=0;
  actualSlant=0;
  wantedSetwidth=0;
  actualSetwidth=0;
  wantedEncoding=0;
  actualEncoding=0;
  hints=0;
  flags=0;
  angle=0;
  font=NULL;
#ifdef WIN32
  dc=NULL;
#endif
  setFont(string);
  }


// Construct a font with given family name, size in points(pixels), weight, slant, character set encoding, setwidth, and hints
FXFont::FXFont(FXApp* a,const FXString& face,FXuint size,FXuint weight,FXuint slant,FXuint encoding,FXuint setwidth,FXuint h):FXId(a),wantedName(face){
  FXTRACE((100,"FXFont::FXFont %p\n",this));
  wantedSize=10*size;
  wantedWeight=weight;
  wantedSlant=slant;
  wantedSetwidth=setwidth;
  wantedEncoding=encoding;
  actualSize=0;
  actualWeight=0;
  actualSlant=0;
  actualSetwidth=0;
  actualEncoding=0;
  hints=(h&~FXFont::X11);          // System-independent method
  flags=0;
  angle=0;
  font=NULL;
#ifdef WIN32
  dc=NULL;
#endif
  }


// Construct font from font description
FXFont::FXFont(FXApp* a,const FXFontDesc& fontdesc):FXId(a),wantedName(fontdesc.face){
  FXTRACE((100,"FXFont::FXFont %p\n",this));
  wantedSize=fontdesc.size;
  wantedWeight=fontdesc.weight;
  wantedSlant=fontdesc.slant;
  wantedSetwidth=fontdesc.setwidth;
  wantedEncoding=fontdesc.encoding;
  actualSize=0;
  actualWeight=0;
  actualSlant=0;
  actualSetwidth=0;
  actualEncoding=0;
  hints=fontdesc.flags;
  flags=0;
  angle=0;
  font=NULL;
#ifdef WIN32
  dc=NULL;
#endif
  }


// Return family part of name
FXString FXFont::getFamily() const {
  return wantedName.before('[').trimEnd();
  }


// Return foundry part of name
FXString FXFont::getFoundry() const {
  return wantedName.section("[]",1);
  }


/*******************************************************************************/


// Create font
void FXFont::create(){
  if(!xid){
    if(getApp()->isInitialized()){
      FXTRACE((100,"%s::create %p\n",getClassName(),this));

#if defined(WIN32)              ///// WIN32 /////

      FXString family=getFamily();

      FXTRACE((150,"%s::create: win32 font\n",getClassName()));

      // Try to match with specified family and foundry
      if(!family.empty()){
        family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS",family.text(),family.text());
        font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,100);
        }

      // Uh-oh, we failed
      if(!xid){ throw FXFontException("unable to create font"); }

#elif defined(HAVE_XFT_H)       ///// XFT /////

      FXString family=getFamily();
      FXString foundry=getFoundry();
      FXint    res;

      // Override screen resolution via registry
      res=getApp()->reg().readUnsignedEntry("SETTINGS","screenres",100);

      FXTRACE((150,"%s::create: xft font\n",getClassName()));

      // Try to match with specified family and foundry
      if(!family.empty()){
        family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS",family.text(),family.text());
        if(!foundry.empty()){
          foundry=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS",foundry.text(),foundry.text());
          font=match(family,foundry,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
          }
        if(!font){
          font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
          }
        }

      // Uh-oh, we failed
      if(!xid){ throw FXFontException("unable to create font"); }

#else                           ///// XLFD /////

      FXString family=getFamily();
      FXString foundry=getFoundry();
      FXint    res;

      // Override screen resolution via registry
      res=getApp()->reg().readUnsignedEntry("SETTINGS","screenres",100);

      FXTRACE((150,"%s::create: xlfd font\n",getClassName()));

      // X11 font specification
      if(hints&FXFont::X11){

        // Resolve font name
        actualName=xlfdFont(DISPLAY(getApp()),wantedName);

        // Try load the font
        font=XLoadQueryFont(DISPLAY(getApp()),actualName.text());
        }

      // Platform independent specification
      if(!font){

        // First we try to match with specified family and foundry
        if(!family.empty()){
          family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS",family.text(),family.text());
          if(!foundry.empty()){
            foundry=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS",foundry.text(),foundry.text());
            font=match(family,foundry,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            }
          if(!font){
            font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            }
          }

        // Try based on hints
        if(!font){

          // Try swiss if we want swiss or indicated no preference
          if((hints&(FXFont::Swiss|FXFont::System)) || !(hints&(FXFont::Decorative|FXFont::Modern|FXFont::Roman|FXFont::Script|FXFont::Swiss|FXFont::System))){
            family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","helvetica","helvetica");
            font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            if(!font){
              family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","lucida","lucida");
              font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
              }
            }

          // Try roman
          else if(hints&FXFont::Roman){
            family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","times","times");
            font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            if(!font){
              family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","charter","charter");
              font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
              }
            }

          // Try modern
          else if(hints&FXFont::Modern){
            family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","courier","courier");
            font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            if(!font){
              family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","lucidatypewriter","lucidatypewriter");
              font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
              }
            }

          // Try decorative
          else if(hints&FXFont::Decorative){
            family=getApp()->reg().readStringEntry("FONTSUBSTITUTIONS","gothic","gothic");
            font=match(family,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            }

          // Try anything
          if(!font){
            font=match(FXString::null,FXString::null,wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding,hints,res);
            }
          }
        }

      // If we still don't have a font yet, use fixed font
      if(!font){

        // Resolve font name
        actualName="fixed";

        // Try load the font
        font=XLoadQueryFont(DISPLAY(getApp()),actualName.text());
        }

      // Remember font id
      if(font){ xid=((XFontStruct*)font)->fid; }

      // Uh-oh, we failed
      if(!xid){ throw FXFontException("unable to create font"); }

#endif

      // What was really matched
      FXTRACE((100,"wantedName=%s wantedSize=%d wantedWeight=%d wantedSlant=%d wantedSetwidth=%d wantedEncoding=%d\n",wantedName.text(),wantedSize,wantedWeight,wantedSlant,wantedSetwidth,wantedEncoding));
      FXTRACE((100,"actualName=%s actualSize=%d actualWeight=%d actualSlant=%d actualSetwidth=%d actualEncoding=%d\n",actualName.text(),actualSize,actualWeight,actualSlant,actualSetwidth,actualEncoding));
      }
    }
  }


// Detach font
void FXFont::detach(){
  if(xid){
    FXTRACE((100,"%s::detach %p\n",getClassName(),this));

#if defined(WIN32)              ///// WIN32 /////

    // Free font metrics
    FXFREE(&font);

#elif defined(HAVE_XFT_H)       ///// XFT /////

    XftFontClose(DISPLAY(getApp()),(XftFont*)font);

#else                           ///// XLFD /////

    XFreeFont(DISPLAY(getApp()),(XFontStruct*)font);

#endif

    // Forget all about actual font
    actualName=FXString::null;
    actualSize=0;
    actualWeight=0;
    actualSlant=0;
    actualSetwidth=0;
    actualEncoding=0;
    font=NULL;
    xid=0;
    }
  }


// Destroy font
void FXFont::destroy(){
  if(xid){
    if(getApp()->isInitialized()){
      FXTRACE((100,"%s::destroy %p\n",getClassName(),this));

#if defined(WIN32)              ///// WIN32 /////

      // Necessary to prevent resource leak
      SelectObject((HDC)dc,GetStockObject(SYSTEM_FONT));

      // Delete font
      DeleteObject((HFONT)xid);

      // Delete dummy DC
      DeleteDC((HDC)dc);

      // Free font metrics
      FXFREE(&font);

#elif defined(HAVE_XFT_H)       ///// XFT /////

      // Free font
      XftFontClose(DISPLAY(getApp()),(XftFont*)font);

#else                           ///// XLFD /////

      // Free font
      XFreeFont(DISPLAY(getApp()),(XFontStruct*)font);

#endif
      }

    // Forget all about actual font
    actualName=FXString::null;
    actualSize=0;
    actualWeight=0;
    actualSlant=0;
    actualSetwidth=0;
    actualEncoding=0;
    font=NULL;
    xid=0;
    }
  }


/*******************************************************************************/


// Set to new angle, in degrees*64 relative to positive x axis
void FXFont::setAngle(FXint ang){
  if(xid){ fxerror("%s::setAngle: font has already been created.\n",getClassName()); }
  angle=(ang+34560)%23040-11520;
  if(angle!=ang){
    angle=ang;
    }
  }

/*
WINGDIAPI DWORD WINAPI GetGlyphIndices(
  HDC hdc,       // handle to DC
  LPCTSTR lpstr, // string to convert
  int c,         // number of characters in string
  LPWORD pgi,    // array of glyph indices
  DWORD fl       // glyph options
);
Parameters
hdc
[in] Handle to the device context.
lpstr
[in] Pointer to the string to be converted.
c
[in] Number of characters in pgi.
pgi
[out] Array of glyph indices corresponding to the characters in the string.
fl
[in] Specifies how glyphs should be handled if they are not supported. This parameter can be the following value. Value Meaning
GGI_MARK_NONEXISTING_GLYPHS Marks unsupported glyphs with the hexadecimal value 0xffff.


*/

// Does font have given character glyph?
FXbool FXFont::hasChar(FXwchar ch) const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    // FIXME may want to use GetGlyphIndices()
    return ((TEXTMETRIC*)font)->tmFirstChar<=ch && ch<=((TEXTMETRIC*)font)->tmLastChar;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return XftCharExists(DISPLAY(getApp()),(XftFont*)font,ch);
#else                           ///// XLFD /////
    register const XFontStruct *fs=(XFontStruct*)font;
    register const XCharStruct *cm;
    register FXuchar row=ch>>8;
    register FXuchar col=ch&255;
    if(fs->min_char_or_byte2<=col && col<=fs->max_char_or_byte2 && fs->min_byte1<=row && row<=fs->max_byte1){
      if(!fs->per_char) return TRUE;
      cm=fs->per_char+((row-fs->min_byte1)*(fs->max_char_or_byte2-fs->min_char_or_byte2+1))+(col-fs->min_char_or_byte2);
      if(cm->width || cm->ascent || cm->descent || cm->rbearing || cm->lbearing) return TRUE;
      }
#endif
    }
  return FALSE;
  }


// Get first character glyph in font
FXwchar FXFont::getMinChar() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmFirstChar;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return 0;                                           // FIXME
#else                           ///// XLFD /////
    return (((XFontStruct*)font)->min_byte1<<8)|((XFontStruct*)font)->min_char_or_byte2;
#endif
    }
  return 0;
  }


// Get last character glyph in font
FXwchar FXFont::getMaxChar() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmLastChar;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return 0x10ffff;                                    // FIXME
#else                           ///// XLFD /////
    return (((XFontStruct*)font)->max_byte1<<8)|((XFontStruct*)font)->max_char_or_byte2;
#endif
    }
  return 0;
  }


// Get font leading [that is lead-ing as in Pb!]
FXint FXFont::getFontLeading() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmExternalLeading;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return 0;                                           // FIXME
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->ascent+((XFontStruct*)font)->descent-((XFontStruct*)font)->max_bounds.ascent-((XFontStruct*)font)->max_bounds.descent;
#endif
    }
  return 0;
  }


// Get font line spacing [height+leading]
FXint FXFont::getFontSpacing() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmHeight;               // Includes font point size plus internal leading
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return ((XftFont*)font)->ascent+((XftFont*)font)->descent;
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->ascent+((XFontStruct*)font)->descent;
#endif
    }
  return 1;
  }


// Left bearing
FXint FXFont::leftBearing(FXwchar ch) const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return 0;                                           // FIXME
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return 0;                                           // FIXME
#else                           ///// XLFD /////
    register const XFontStruct *fs=(XFontStruct*)font;
    if(fs->per_char){
      register FXuchar row=ch>>8;
      register FXuchar col=ch&255;
      if(fs->min_char_or_byte2<=col && col<=fs->max_char_or_byte2 && fs->min_byte1<=row && row<=fs->max_byte1){
        register const XCharStruct *cm=fs->per_char+((row-fs->min_byte1)*(fs->max_char_or_byte2-fs->min_char_or_byte2+1))+(col-fs->min_char_or_byte2);
        if(cm->width || cm->ascent || cm->descent) return cm->lbearing;
        }
      return fs->per_char[((fs->default_char>>8)-fs->min_byte1)*(fs->max_char_or_byte2-fs->min_char_or_byte2+1)+((fs->default_char&255)-fs->min_char_or_byte2)].lbearing;
      }
    return fs->min_bounds.lbearing;
#endif
    }
  return 0;
  }


// Right bearing
FXint FXFont::rightBearing(FXwchar ch) const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return 0;                                           // FIXME
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return 0;                                           // FIXME
#else                           ///// XLFD /////
    register const XFontStruct *fs=(XFontStruct*)font;
    if(fs->per_char){
      register FXuchar row=ch>>8;
      register FXuchar col=ch&255;
      if(fs->min_char_or_byte2<=col && col<=fs->max_char_or_byte2 && fs->min_byte1<=row && row<=fs->max_byte1){
        register const XCharStruct *cm=fs->per_char+((row-fs->min_byte1)*(fs->max_char_or_byte2-fs->min_char_or_byte2+1))+(col-fs->min_char_or_byte2);
        if(cm->width || cm->ascent || cm->descent) return cm->rbearing;
        }
      return fs->per_char[((fs->default_char>>8)-fs->min_byte1)*(fs->max_char_or_byte2-fs->min_char_or_byte2+1)+((fs->default_char&255)-fs->min_char_or_byte2)].rbearing;
      }
    return fs->min_bounds.rbearing;
#endif
    }
  return 0;
  }


// Is it a mono space font
FXbool FXFont::isFontMono() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return !(((TEXTMETRIC*)font)->tmPitchAndFamily&TMPF_FIXED_PITCH);
#elif defined(HAVE_XFT_H)       ///// XFT /////
    XGlyphInfo i_extents,m_extents;
    XftTextExtents8(DISPLAY(getApp()),(XftFont*)font,(const FcChar8*)"i",1,&i_extents); // FIXME better than before but no cigar yet
    XftTextExtents8(DISPLAY(getApp()),(XftFont*)font,(const FcChar8*)"M",1,&m_extents);
    return i_extents.xOff==m_extents.xOff;
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->min_bounds.width == ((XFontStruct*)font)->max_bounds.width;
#endif
    }
  return TRUE;
  }


// Get font width
FXint FXFont::getFontWidth() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmMaxCharWidth;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return ((XftFont*)font)->max_advance_width;
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->max_bounds.width;
#endif
    }
  return 1;
  }


// Get font height
FXint FXFont::getFontHeight() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmHeight;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return ((XftFont*)font)->ascent+((XftFont*)font)->descent;
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->ascent+((XFontStruct*)font)->descent;
#endif
    }
  return 1;
  }


// Get font ascent
FXint FXFont::getFontAscent() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmAscent;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return ((XftFont*)font)->ascent;
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->ascent;
#endif
    }
  return 1;
  }


// Get font descent
FXint FXFont::getFontDescent() const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    return ((TEXTMETRIC*)font)->tmDescent;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    return ((XftFont*)font)->descent;
#else                           ///// XLFD /////
    return ((XFontStruct*)font)->descent;
#endif
    }
  return 0;
  }


// Calculate width of single wide character in this font
FXint FXFont::getCharWidth(const FXwchar ch) const {
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    FXnchar sbuffer[2];
    SIZE size;
    sbuffer[0]=ch;
    if(0xFFFF<ch){                      // Deal with surrogate pair
      sbuffer[0]=(ch>>10)+LEAD_OFFSET;
      sbuffer[1]=(ch&0x3FF)+0xDC00;
      GetTextExtentPoint32W((HDC)dc,sbuffer,2,&size);
      return size.cx;
      }
    GetTextExtentPoint32W((HDC)dc,sbuffer,1,&size);
    return size.cx;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    XGlyphInfo extents;
    XftTextExtents32(DISPLAY(getApp()),(XftFont*)font,(const FcChar32*)&ch,1,&extents);
    return extents.xOff;
#else                           ///// XLFD /////
    register const XFontStruct *fs=(XFontStruct*)font;
    register FXint width,size;
    register FXuchar r,c;
    if(fs->per_char){
      r=ch>>8;
      c=ch&255;
      size=(fs->max_char_or_byte2-fs->min_char_or_byte2+1);
      if(fs->min_char_or_byte2<=c && c<=fs->max_char_or_byte2 && fs->min_byte1<=r && r<=fs->max_byte1){
        width=fs->per_char[(r-fs->min_byte1)*size+(c-fs->min_char_or_byte2)].width;
        if(width) return width;
        }
      r=fs->default_char>>8;
      c=fs->default_char&255;
      if(fs->min_char_or_byte2<=c && c<=fs->max_char_or_byte2 && fs->min_byte1<=r && r<=fs->max_byte1){
        return fs->per_char[(r-fs->min_byte1)*size+(c-fs->min_char_or_byte2)].width;
        }
      }
    return fs->min_bounds.width;
#endif
    }
  return 1;
  }


// Text width
FXint FXFont::getTextWidth(const FXchar *string,FXuint length) const {
  if(!string && length){ fxerror("%s::getTextWidth: NULL string argument\n",getClassName()); }
  if(font){
#if defined(WIN32)              ///// WIN32 /////
    FXnchar sbuffer[4096];
    FXASSERT(dc!=NULL);
    FXint count=utf2ncs(sbuffer,string,FXMIN(length,4096));
    FXASSERT(count<=length);
    SIZE size;
    GetTextExtentPoint32W((HDC)dc,sbuffer,count,&size);
    return size.cx;
#elif defined(HAVE_XFT_H)       ///// XFT /////
    XGlyphInfo extents;
    // This returns rotated metrics; FOX likes to work with unrotated metrics, so if angle
    // is not 0, we calculate the unrotated baseline; note however that the calculation is
    // not 100% pixel exact when the angle is not a multiple of 90 degrees.
    XftTextExtentsUtf8(DISPLAY(getApp()),(XftFont*)font,(const FcChar8*)string,length,&extents);
    if(angle){ return (FXint)(0.5+sqrt(extents.xOff*extents.xOff+extents.yOff*extents.yOff)); }
    return extents.xOff;
#else                           ///// XLFD /////
    register const XFontStruct *fs=(XFontStruct*)font;
    register FXint defwidth=fs->min_bounds.width;
    register FXint width=0,ww;
    register FXuint p=0;
    register FXuint s;
    register FXuchar r;
    register FXuchar c;
    register FXwchar w;
    if(fs->per_char){
      r=fs->default_char>>8;
      c=fs->default_char&255;
      s=(fs->max_char_or_byte2-fs->min_char_or_byte2+1);
      if(fs->min_char_or_byte2<=c && c<=fs->max_char_or_byte2 && fs->min_byte1<=r && r<=fs->max_byte1){
        defwidth=fs->per_char[(r-fs->min_byte1)*s+(c-fs->min_char_or_byte2)].width;
        }
      while(p<length){
        w=wc(string+p);
        p+=wclen(string+p);
        r=w>>8;
        c=w&255;
        if(fs->min_char_or_byte2<=c && c<=fs->max_char_or_byte2 && fs->min_byte1<=r && r<=fs->max_byte1){
          if((ww=fs->per_char[(r-fs->min_byte1)*s+(c-fs->min_char_or_byte2)].width)!=0){
            width+=ww;
            continue;
            }
          }
        width+=defwidth;
        }
      }
    else{
      while(p<length){
        p+=wclen(string+p);
        width+=defwidth;
        }
      }
    return width;
#endif
    }
  return length;
  }


// Text width
FXint FXFont::getTextWidth(const FXString& string) const {
  return getTextWidth(string.text(),string.length());
  }


// Text height
FXint FXFont::getTextHeight(const FXchar *string,FXuint length) const {
  if(!string && length){ fxerror("%s::getTextHeight: NULL string argument\n",getClassName()); }
  if(font){
#if defined(WIN32)              ///// WIN32 /////
//    SIZE size;
//    FXASSERT(dc!=NULL);
//    GetTextExtentPoint32((HDC)dc,string,length,&size);
//    return size.cy;
    return ((TEXTMETRIC*)font)->tmHeight;
#elif defined(HAVE_XFT_H)       ///// XFT /////
//    XGlyphInfo extents;
//    XftTextExtents8(DISPLAY(getApp()),(XftFont*)font,(const FcChar8*)text,n,&extents);
//    return extents.height; // TODO: Is this correct?
    // Patch from ivan.markov@wizcom.bg
    return ((XftFont*)font)->ascent+((XftFont*)font)->descent;
#else                           ///// XLFD /////
//    XCharStruct chst; int dir,asc,desc;
//    XTextExtents((XFontStruct*)font,string,length,&dir,&asc,&desc,&chst);
//    return asc+desc;
    return ((XFontStruct*)font)->ascent+((XFontStruct*)font)->descent;
#endif
    }
  return 1;
  }


// Text height
FXint FXFont::getTextHeight(const FXString& string) const {
  return getTextHeight(string.text(),string.length());
  }


/*
static FX88591Codec codec_8859_1;
static FX88592Codec codec_8859_2;
static FX88593Codec codec_8859_3;
static FX88594Codec codec_8859_4;
static FX88595Codec codec_8859_5;
static FX88596Codec codec_8859_6;
static FX88597Codec codec_8859_7;
static FX88598Codec codec_8859_8;
static FX88599Codec codec_8859_9;
static FX885910Codec codec_8859_10;
static FX885911Codec codec_8859_11;
static FX885913Codec codec_8859_13;
static FX885914Codec codec_8859_14;
static FX885915Codec codec_8859_15;
static FX885916Codec codec_8859_16;

  FXchar sbuffer[4096];
  switch(actualEncoding){
    case FONTENCODING_ISO_8859_1: count=codec_8859_1.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_2: count=codec_8859_2.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_3: count=codec_8859_3.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_4: count=codec_8859_4.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_5: count=codec_8859_5.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_6: count=codec_8859_6.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_7: count=codec_8859_7.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_8: count=codec_8859_8.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_9: count=codec_8859_9.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_10: count=codec_8859_10.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_11: count=codec_8859_11.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_13: count=codec_8859_13.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_14: count=codec_8859_14.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_15: count=codec_8859_15.utf2mb(sbuffer,4096,string,length); break;
    case FONTENCODING_ISO_8859_16: count=codec_8859_16.utf2mb(sbuffer,4096,string,length); break;
    default: count=0; break;
    }
  XDrawString(DISPLAY(getApp()),((FXDCWindow*)dc)->surface->id(),(GC)((FXDCWindow*)dc)->ctx,x,y,sbuffer,count);
*/


/*
  /// Draw text starting at x,y
  virtual void drawText(FXDC* dc,FXint x,FXint y,const FXString& string) const;

  /// Draw text starting at x,y
  virtual void drawText(FXDC* dc,FXint x,FXint y,const FXchar* string,FXuint length) const;

  /// Draw text starting at x,y over filled background
  virtual void drawImageText(FXDC* dc,FXint x,FXint y,const FXString& string) const;

  /// Draw text starting at x,y over filled background
  virtual void drawImageText(FXDC* dc,FXint x,FXint y,const FXchar* string,FXuint length) const;


#if defined(WIN32)              ///// WIN32 /////

// Draw text starting at x,y
void FXFont::drawText(FXDC* dc,FXint x,FXint y,const FXchar* string,FXuint length) const {
  FXnchar sbuffer[4096];
  FXint iBkMode=SetBkMode((HDC)dc->ctx,TRANSPARENT);
  FXint count=utf2ncs(sbuffer,string,FXMIN(length,4096));
  FXASSERT(count<=length);
  TextOutW((HDC)dc->ctx,x,y,sbuffer,count);
  SetBkMode((HDC)dc->ctx,iBkMode);
  }

#elif defined(HAVE_XFT_H)       ///// XFT /////

// Draw text starting at x,y
void FXFont::drawText(FXDC* dc,FXint x,FXint y,const FXchar* string,FXuint length) const {
  XftColor color;
  color.pixel=((FXDCWindow*)dc)->devfg;
  color.color.red=FXREDVAL(((FXDCWindow*)dc)->fg)*257;
  color.color.green=FXGREENVAL(((FXDCWindow*)dc)->fg)*257;
  color.color.blue=FXBLUEVAL(((FXDCWindow*)dc)->fg)*257;
  color.color.alpha=FXALPHAVAL(((FXDCWindow*)dc)->fg)*257;
  XftDrawStringUtf8((XftDraw*)((FXDCWindow*)dc)->xftDraw,&color,(XftFont*)((FXDCWindow*)dc)->font->font,x,y,(const FcChar8*)string,length);
  }

#else                           ///// XLFD /////

static FXint utf2db(XChar2b *dst,const FXchar *src,FXint n){
  register FXint len,p;
  register FXwchar w;
  for(p=len=0; p<n; p+=wclen(src+p),len++){
    w=wc(src+p);
    dst[len].byte1=(w>>8);
    dst[len].byte2=(w&255);
    }
  return len;
  }


// Draw text starting at x,y
void FXFont::drawText(FXDC* dc,FXint x,FXint y,const FXchar* string,FXuint length) const {
  register const XFontStruct *fs=(XFontStruct*)font;
  register FXint count,escapement,defwidth,ww,size,i;
  register FXdouble ang,ux,uy;
  register FXuchar r,c;
  XChar2b sbuffer[4096];
  count=utf2db(sbuffer,string,FXMIN(length,4096));
  FXASSERT(count<=length);
  if(angle){
    ang=angle*0.00027270769562411399179;
    defwidth=fs->min_bounds.width;
    ux=cos(ang);
    uy=sin(ang);
    if(fs->per_char){
      r=fs->default_char>>8;
      c=fs->default_char&255;
      size=(fs->max_char_or_byte2-fs->min_char_or_byte2+1);
      if(fs->min_char_or_byte2<=c && c<=fs->max_char_or_byte2 && fs->min_byte1<=r && r<=fs->max_byte1){
        defwidth=fs->per_char[(r-fs->min_byte1)*size+(c-fs->min_char_or_byte2)].width;
        }
      for(i=escapement=0; i<count; i++){
        XDrawString16(DISPLAY(getApp()),((FXDCWindow*)dc)->surface->id(),(GC)((FXDCWindow*)dc)->ctx,(FXint)(x+escapement*ux),(FXint)(y-escapement*uy),&sbuffer[i],1);
        r=sbuffer[i].byte1;
        c=sbuffer[i].byte2;
        escapement+=defwidth;
        if(fs->min_char_or_byte2<=c && c<=fs->max_char_or_byte2 && fs->min_byte1<=r && r<=fs->max_byte1){
          if((ww=fs->per_char[(r-fs->min_byte1)*size+(c-fs->min_char_or_byte2)].width)!=0) escapement+=ww-defwidth;
          }
        }
      }
    else{
      for(i=escapement=0; i<count; i++){
        XDrawString16(DISPLAY(getApp()),((FXDCWindow*)dc)->surface->id(),(GC)((FXDCWindow*)dc)->ctx,(FXint)(x+escapement*ux),(FXint)(y-escapement*uy),&sbuffer[i],1);
        escapement+=defwidth;
        }
      }
    }
  else{
    XDrawString16(DISPLAY(getApp()),((FXDCWindow*)dc)->surface->id(),(GC)((FXDCWindow*)dc)->ctx,x,y,sbuffer,count);
    }
  }


#endif


// Draw text starting at x,y
void FXFont::drawText(FXDC* dc,FXint x,FXint y,const FXString& string) const {
  drawText(dc,x,y,string.text(),string.length());
  }



// Draw text starting at x,y over filled background
void FXFont::drawImageText(FXDC* dc,FXint x,FXint y,const FXchar* string,FXuint length) const {
  // ...
  }


// Draw text starting at x,y over filled background
void FXFont::drawImageText(FXDC* dc,FXint x,FXint y,const FXString& string) const {
  drawImageText(dc,x,y,string.text(),string.length());
  }
*/


/*******************************************************************************/


// Function to sort by name, weight, slant, and size
static int comparefont(const void *a,const void *b){
  register FXFontDesc *fa=(FXFontDesc*)a;
  register FXFontDesc *fb=(FXFontDesc*)b;
  register FXint cmp=strcmp(fa->face,fb->face);
  return cmp ? cmp : (fa->weight!=fb->weight) ? fa->weight-fb->weight : (fa->slant!=fb->slant) ? fa->slant-fb->slant : fa->size-fb->size;
  }



#if defined(WIN32)              ///////  MS-Windows ///////

// List all fonts matching hints
FXbool FXFont::listFonts(FXFontDesc*& fonts,FXuint& numfonts,const FXString& face,FXuint wt,FXuint sl,FXuint sw,FXuint en,FXuint h){
  register FXuint i,j;

  // Initialize return values
  fonts=NULL;
  numfonts=0;

  // This data gets passed into the callback function
  FXFontStore fontStore;
  HDC hdc=GetDC(GetDesktopWindow());
  SaveDC(hdc);
  fontStore.hdc=hdc;
  fontStore.fonts=fonts;
  fontStore.numfonts=numfonts;
  fontStore.desc.weight=wt;
  fontStore.desc.slant=sl;
  fontStore.desc.setwidth=sw;
  fontStore.desc.encoding=en;
  fontStore.desc.flags=h;

  // Fill in the appropriate fields of the LOGFONT structure. Note that
  // EnumFontFamiliesEx() only examines the lfCharSet, lfFaceName and
  // lpPitchAndFamily fields of this struct.
  LOGFONTA lf;
  lf.lfHeight=0;
  lf.lfWidth=0;
  lf.lfEscapement=0;
  lf.lfOrientation=0;
  lf.lfWeight=0;
  lf.lfItalic=0;
  lf.lfUnderline=0;
  lf.lfStrikeOut=0;
  lf.lfCharSet=FXFontEncoding2CharSet(en);
  lf.lfOutPrecision=0;
  lf.lfClipPrecision=0;
  lf.lfQuality=0;
  lf.lfPitchAndFamily=0;                          // Should be MONO_FONT for Hebrew and Arabic?
  FXASSERT(face.length()<LF_FACESIZE);
  strncpy(lf.lfFaceName,face.text(),LF_FACESIZE);

  // Start enumerating!
  EnumFontFamiliesExA(hdc,&lf,EnumFontFamExProc,(LPARAM)&fontStore,0);
  RestoreDC(hdc,-1);
  ReleaseDC(GetDesktopWindow(),hdc);

  // Copy stuff back from the store
  fonts=fontStore.fonts;
  numfonts=fontStore.numfonts;

  // Any fonts found?
  if(numfonts==0){
    FXFREE(&fonts);
    return FALSE;
    }

  // Sort them by name, weight, slant, and size respectively
  ::qsort(fonts,numfonts,sizeof(FXFontDesc),comparefont);

  // Weed out duplicates if we were just listing the face names
  if(lf.lfCharSet==DEFAULT_CHARSET && lf.lfFaceName[0]==0){
    i=j=1;
    while(j<numfonts){
      if(strcmp(fonts[i-1].face,fonts[j].face)!=0){
        fonts[i]=fonts[j];
        i++;
        }
      j++;
      }
    numfonts=i;
    }

  // Realloc to shrink the block
  FXRESIZE(&fonts,FXFontDesc,numfonts);

//   FXTRACE((150,"%d fonts:\n",numfonts));
//   for(FXuint f=0; f<numfonts; f++){
//     FXTRACE((150,"Font=%s weight=%d slant=%d size=%3d setwidth=%d encoding=%d\n",fonts[f].face,fonts[f].weight,fonts[f].slant,fonts[f].size,fonts[f].setwidth,fonts[f].encoding));
//     }
//   FXTRACE((150,"\n\n"));

  return TRUE;
  }


#elif defined(HAVE_XFT_H)       ///////  X Freetype ///////


// List all fonts that match the passed requirements
FXbool FXFont::listFonts(FXFontDesc*& fonts,FXuint& numfonts,const FXString& face,FXuint wt,FXuint sl,FXuint sw,FXuint en,FXuint h){
  int          encoding,setwidth,weight,slant,size,pitch,scalable,res,i,j;
  FXchar       fullname[256];
  FcPattern   *pattern,*p;
  FcObjectSet *objset;
  FcFontSet   *fontset;
  FcChar8     *fam,*fdy;
  FcBool       scale;
  FcCharSet   *charset;
  FXString     family;
  FXString     foundry;
  double       points;

  fonts=NULL;
  numfonts=0;

  // Need to have application
  if(!FXApp::instance()){ fxerror("FXFont::listFonts: no application object.\n"); }

  // Need to have display open
  if(!DISPLAY(FXApp::instance())){ fxerror("FXFont::listFonts: trying to list fonts before opening display.\n"); }

  // Get family part of name
  family=face.before('[').trimEnd();

  // Get foundry part of name
  foundry=face.section("[]",1);

  FXTRACE((150,"FXFont::listFonts: family=\"%s\" foundry=\"%s\" weight=%d slant=%d setwidth=%d encoding=%d hints=%x\n",family.text(),foundry.text(),wt,sl,sw,en,h));

  // Screen resolution may be overidden by registry
  res=FXApp::instance()->reg().readUnsignedEntry("SETTINGS","screenres",100);

  // Build object set
  objset=FcObjectSetBuild(FC_FAMILY,FC_FOUNDRY,FC_SPACING,FC_SCALABLE,FC_WIDTH,FC_WEIGHT,FC_SLANT,FC_PIXEL_SIZE,NULL);
  if(objset){

    // Create pattern object
    pattern=FcPatternCreate();
    if(pattern){

      // Set family
      if(!family.empty()){
        FcPatternAddString(pattern,FC_FAMILY,(const FcChar8*)family.text());
        }

      // Set foundry
      if(!foundry.empty()){
        FcPatternAddString(pattern,FC_FOUNDRY,(const FcChar8*)foundry.text());
        }

      // If we set this we get no fonts
//      if(h&FXFont::Rotatable){
//        const FcMatrix matrix={1.0,0.0,0.0,1.0};
//        FcPatternAddMatrix(pattern,FC_MATRIX,&matrix);
//        }

      // List fonts matching pattern
      fontset=FcFontList(0,pattern,objset);
      if(fontset && 0<fontset->nfont){

        // Allocate return array
        if(FXMALLOC(&fonts,FXFontDesc,fontset->nfont)){

          // Collect the info now...
          for(i=0; i<fontset->nfont; i++){
            p=fontset->fonts[i];

            // Get full face name
            fullname[0]=0;
            if(FcPatternGetString(p,FC_FAMILY,0,&fam)==FcResultMatch){
              strcpy(fullname,(const char*)fam);
              if(FcPatternGetString(p,FC_FOUNDRY,0,&fdy)==FcResultMatch){
                strcat(fullname," [");
                strcat(fullname,(const char*)fdy);
                strcat(fullname,"]");
                }
              }

            // Get setwidth
            setwidth=0;
            if(FcPatternGetInteger(p,FC_WIDTH,0,&setwidth)==FcResultMatch){
              setwidth=fcSetWidth2SetWidth(setwidth);
              }

            // Get weight
            weight=0;
            if(FcPatternGetInteger(p,FC_WEIGHT,0,&weight)==FcResultMatch){
              weight=fcWeight2Weight(weight);
              }

            // Get slant
            slant=0;
            if(FcPatternGetInteger(p,FC_SLANT,0,&slant)==FcResultMatch){
              slant=fcSlant2Slant(slant);
              }

            // Get pitch
            pitch=FXFont::Variable;
            if(FcPatternGetInteger(p,FC_SPACING,0,&pitch)==FcResultMatch){
//              if(pitch==FC_MONO || pitch==FC_DUAL || pitch==FC_CHARCELL) pitch=FXFont::Fixed;
              if(pitch==FC_MONO || pitch==FC_CHARCELL) pitch=FXFont::Fixed;
              }

            // Pixel size works for both bitmap and scalable fonts
            size=0;
            if(FcPatternGetDouble(p,FC_PIXEL_SIZE,0,&points)==FcResultMatch){
              size=(int)((720.0*points)/res);
              }

            // Get scalable flag
            scalable=0;
            if(FcPatternGetBool(p,FC_SCALABLE,0,&scale)==FcResultMatch){
              if(scale) scalable=FXFont::Scalable;
              }

            // Get charset
            if(FcPatternGetCharSet(p,FC_CHARSET,0,&charset)==FcResultMatch){    // FIXME
              }

            // Get the encoding
            encoding=FONTENCODING_UNICODE;

            FXTRACE((160,"wt=%2d sl=%d sw=%3d en=%5d sz=%3d sc=%4x pi=%d name=%s\n",weight,slant,setwidth,encoding,size,scalable,pitch,fullname));

            // Skip if pitch does not match
            if((h&FXFont::Fixed) && (pitch!=FXFont::Fixed)) continue;
            if((h&FXFont::Variable) && (pitch!=FXFont::Variable)) continue;

            // Skip if weight does not match
            if((wt!=0) && (wt!=weight)) continue;

            // Skip if slant does not match
            if((sl!=0) && (sl!=slant)) continue;

            // Skip if setwidth does not match
            if((sw!=0) && (sw!=setwidth)) continue;

            // Want scalable
            if((h&FXFont::Scalable) && (scalable!=FXFont::Scalable)) continue;

            // If NULL face name, just list one of each face
            if(family.empty()){
              for(j=numfonts-1; j>=0; j--){
                if(strcmp(fullname,fonts[j].face)==0) goto next;
                }
              }

            // Add this font
            strncpy(fonts[numfonts].face,fullname,116);
            fonts[numfonts].size=size;
            fonts[numfonts].weight=weight;
            fonts[numfonts].slant=slant;
            fonts[numfonts].encoding=encoding;
            fonts[numfonts].setwidth=setwidth;
            fonts[numfonts].flags=pitch|scalable;
            numfonts++;

            // Next font
next:       continue;
            }

          // Realloc to shrink the block
          FXRESIZE(&fonts,FXFontDesc,numfonts);

          // Sort them by name, weight, slant, and size respectively
          ::qsort(fonts,numfonts,sizeof(FXFontDesc),comparefont);
          }
        FcFontSetDestroy(fontset);
        }
      FcPatternDestroy(pattern);
      }
    FcObjectSetDestroy(objset);
    }
  return (0<numfonts);
  }


#else                           ///////  X XLFD ///////


// Try find matching font
FXbool FXFont::listFonts(FXFontDesc*& fonts,FXuint& numfonts,const FXString& face,FXuint wt,FXuint sl,FXuint sw,FXuint en,FXuint h){
  FXuint   encoding,weight,slant,setwidth,pitch,scalable,rotatable,polymorph,xres,yres,points,size,res;
  FXchar   candidate[256],fullname[256];
  FXchar  *field[13];
  FXchar **fontnames;
  FXint    nfontnames,f,j;
  FXString family;
  FXString foundry;

  fonts=NULL;
  numfonts=0;

  // Need to have application
  if(!FXApp::instance()){ fxerror("FXFont::listFonts: no application object.\n"); }

  // Need to have display open
  if(!DISPLAY(FXApp::instance())){ fxerror("FXFont::listFonts: trying to list fonts before opening display.\n"); }

  // Screen resolution may be overidden by registry
  res=FXApp::instance()->reg().readUnsignedEntry("SETTINGS","screenres",100);

  // Get family part of name
  family=face.before('[').trimEnd();

  // Get foundry part of name
  foundry=face.section("[]",1);

  FXTRACE((150,"FXFont::listFonts: family=\"%s\" foundry=\"%s\" weight=%d slant=%d setwidth=%d encoding=%d hints=%x\n",family.text(),foundry.text(),wt,sl,sw,en,h));

  // Match RAW X11
  if(h&FXFont::X11){
    sprintf(candidate,"%s",face.empty()?"*":face.text());
    }

  // Match XLFD
  else{
    sprintf(candidate,"-%s-%s-*-*-*-*-*-%s-*-*-*-*-*-*",foundry.empty() ? "*" : foundry.text(),family.empty() ? "*" : family.text(),(h&FXFont::Rotatable) ? "[1 0 0 1]" : "*");
    }

  // Get fonts matching the pattern
  fontnames=XListFonts(DISPLAY(FXApp::instance()),candidate,65535,&nfontnames);
  if(fontnames && 0<nfontnames){

    // Allocate return array
    if(!FXMALLOC(&fonts,FXFontDesc,nfontnames)){ XFreeFontNames(fontnames); return FALSE; }

    // List them
    for(f=0; f<nfontnames; f++){

      // Break apart into fields
      strncpy(candidate,fontnames[f],sizeof(candidate));
      xlfdSplit(field,candidate);

      // Get info
      weight=xlfdWeight(field[2]);
      slant=xlfdSlant(field[3]);
      setwidth=xlfdSetwidth(field[4]);
      scalable=xlfdScalable(field[6],field[7],field[11]);
      polymorph=xlfdPolymorph(field[2],field[3],field[4],field[5]);
      rotatable=xlfdRotatable(field[6],field[7]);
      points=atoi(field[7]);
      xres=atoi(field[8]);
      yres=atoi(field[9]);
      pitch=xlfdPitch(field[10]);
      encoding=xlfdEncoding(field[12]);

      FXTRACE((160,"wt=%2d sl=%d sw=%3d en=%5d pt=%3d sc=%4x po=%4x ro=%4x xlfd=%s\n",weight,slant,setwidth,encoding,points,scalable,polymorph,rotatable,fontnames[f]));

      // The font can be rendered at any resolution
      if(xres==0 && yres==0){ xres=res; yres=res; }

      // Skip if encoding does not match
      if((en!=FONTENCODING_DEFAULT) && (en!=encoding)) continue;

      // Skip if pitch does not match
      if((h&FXFont::Fixed) && (pitch!=FXFont::Fixed)) continue;
      if((h&FXFont::Variable) && (pitch!=FXFont::Variable)) continue;

      // Skip if weight does not match
      if((wt!=0) && (wt!=weight)) continue;

      // Skip if slant does not match
      if((sl!=0) && (sl!=slant)) continue;

      // Skip if setwidth does not match
      if((sw!=0) && (sw!=setwidth)) continue;

      // Want rotatable
      if((h&FXFont::Rotatable) && (rotatable!=FXFont::Rotatable)) continue;

      // Want scalable
      if((h&FXFont::Scalable) && (scalable!=FXFont::Scalable)) continue;

      // If scalable, we can of course get the exact size we want
      if(scalable){
        size=0;
        }

      // Correct for the actual screen resolution
      else{
        size=(yres*points)/res;
        }

      // Get full face name
      strcpy(fullname,field[1]);
      if(field[0][0]){
        strcat(fullname," [");
        strcat(fullname,field[0]);
        strcat(fullname,"]");
        }

      // If NULL face name, just list one of each face
      if(family.empty()){
        for(j=numfonts-1; j>=0; j--){
          if(strcmp(fullname,fonts[j].face)==0) goto next;
          }
        }

      // Add this font
      strncpy(fonts[numfonts].face,fullname,116);
      fonts[numfonts].size=size;
      fonts[numfonts].weight=weight;
      fonts[numfonts].slant=slant;
      fonts[numfonts].encoding=encoding;
      fonts[numfonts].setwidth=setwidth;
      fonts[numfonts].flags=pitch|scalable|polymorph|rotatable;
      numfonts++;

      // Next font
next: continue;
      }

    // Free the list
    XFreeFontNames(fontnames);

    // Realloc to shrink the block
    FXRESIZE(&fonts,FXFontDesc,numfonts);

    // Sort them by name, weight, slant, and size respectively
    ::qsort(fonts,numfonts,sizeof(FXFontDesc),comparefont);
    }
  return (0<numfonts);
  }


#endif


/*******************************************************************************/


// For tables
struct ENTRY { const FXchar *name; FXuint value; };


// Character set encodings
static const ENTRY encodingtable[]={
  {"",FONTENCODING_DEFAULT},
  {"iso10646-1",FONTENCODING_UNICODE},
  {"iso8859-1",FONTENCODING_ISO_8859_1},
  {"iso8859-2",FONTENCODING_ISO_8859_2},
  {"iso8859-3",FONTENCODING_ISO_8859_3},
  {"iso8859-4",FONTENCODING_ISO_8859_4},
  {"iso8859-5",FONTENCODING_ISO_8859_5},
  {"iso8859-6",FONTENCODING_ISO_8859_6},
  {"iso8859-7",FONTENCODING_ISO_8859_7},
  {"iso8859-8",FONTENCODING_ISO_8859_8},
  {"iso8859-9",FONTENCODING_ISO_8859_9},
  {"iso8859-10",FONTENCODING_ISO_8859_10},
  {"iso8859-11",FONTENCODING_ISO_8859_11},
  {"iso8859-13",FONTENCODING_ISO_8859_13},
  {"iso8859-14",FONTENCODING_ISO_8859_14},
  {"iso8859-15",FONTENCODING_ISO_8859_15},
  {"iso8859-16",FONTENCODING_ISO_8859_16},
  {"koi8",FONTENCODING_KOI8},
  {"koi8-r",FONTENCODING_KOI8_R},
  {"koi8-u",FONTENCODING_KOI8_U},
  {"koi8-unified",FONTENCODING_KOI8_UNIFIED},
  {"cp437",FONTENCODING_CP437},
  {"cp850",FONTENCODING_CP850},
  {"cp851",FONTENCODING_CP851},
  {"cp852",FONTENCODING_CP852},
  {"cp855",FONTENCODING_CP855},
  {"cp856",FONTENCODING_CP856},
  {"cp857",FONTENCODING_CP857},
  {"cp860",FONTENCODING_CP860},
  {"cp861",FONTENCODING_CP861},
  {"cp862",FONTENCODING_CP862},
  {"cp863",FONTENCODING_CP863},
  {"cp864",FONTENCODING_CP864},
  {"cp865",FONTENCODING_CP865},
  {"cp866",FONTENCODING_CP866},
  {"cp869",FONTENCODING_CP869},
  {"cp870",FONTENCODING_CP870},
  {"cp1250",FONTENCODING_CP1250},
  {"cp1251",FONTENCODING_CP1251},
  {"cp1252",FONTENCODING_CP1252},
  {"cp1253",FONTENCODING_CP1253},
  {"cp1254",FONTENCODING_CP1254},
  {"cp1255",FONTENCODING_CP1255},
  {"cp1256",FONTENCODING_CP1256},
  {"cp1257",FONTENCODING_CP1257},
  {"cp1258",FONTENCODING_CP1258},
  {"cp874",FONTENCODING_CP874},
  {"ascii",FONTENCODING_ISO_8859_1}
  };


// Font style table
static const ENTRY styletable[]={       // FIXME use or ditch
  {"",0},
  {"decorative",FXFont::Decorative},
  {"modern",FXFont::Modern},
  {"roman",FXFont::Roman},
  {"script",FXFont::Script},
  {"swiss",FXFont::Swiss},
  {"system",FXFont::System}
  };


// Font pitch table
static const ENTRY pitchtable[]={       // FIXME use or ditch
  {"",0},
  {"mono",FXFont::Fixed},
  {"fixed",FXFont::Fixed},
  {"constant",FXFont::Fixed},
  {"variable",FXFont::Variable},
  {"proportional",FXFont::Variable},
  {"c",FXFont::Fixed},
  {"m",FXFont::Fixed},
  {"p",FXFont::Variable}
  };


// Font text angles
static const ENTRY slanttable[]={
  {"",0},
  {"regular",FXFont::Straight},
  {"italic",FXFont::Italic},
  {"oblique",FXFont::Oblique},
  {"normal",FXFont::Straight},
  {"reverse italic",FXFont::ReverseItalic},
  {"reverse oblique",FXFont::ReverseOblique},
  {"r",FXFont::Straight},
  {"n",FXFont::Straight},
  {"i",FXFont::Italic},
  {"o",FXFont::Oblique},
  {"ri",FXFont::ReverseItalic},
  {"ro",FXFont::ReverseOblique}
  };


// Set width table
static const ENTRY setwidthtable[]={
  {"",0},
  {"ultracondensed",FXFont::UltraCondensed},
  {"extracondensed",FXFont::ExtraCondensed},
  {"condensed",FXFont::Condensed},
  {"narrow",FXFont::Condensed},
  {"compressed",FXFont::Condensed},
  {"semicondensed",FXFont::SemiCondensed},
  {"medium",FXFont::NonExpanded},
  {"normal",FXFont::NonExpanded},
  {"regular",FXFont::NonExpanded},
  {"semiexpanded",FXFont::SemiExpanded},
  {"expanded",FXFont::Expanded},
  {"wide",FXFont::ExtraExpanded},
  {"extraexpanded",FXFont::ExtraExpanded},
  {"ultraexpanded",FXFont::UltraExpanded},
  {"n",FXFont::Condensed},
  {"r",FXFont::NonExpanded},
  {"c",FXFont::Condensed},
  {"w",FXFont::ExtraExpanded},
  {"m",FXFont::NonExpanded},
  {"x",FXFont::Expanded}
  };


// Weight table
static const ENTRY weighttable[]={
  {"",0},
  {"thin",FXFont::Thin},
  {"extralight",FXFont::ExtraLight},
  {"light",FXFont::Light},
  {"normal",FXFont::Normal},
  {"regular",FXFont::Normal},
  {"medium",FXFont::Medium},
  {"demibold",FXFont::DemiBold},
  {"bold",FXFont::Bold},
  {"extrabold",FXFont::ExtraBold},
  {"heavy",FXFont::Black},
  {"black",FXFont::Black},
  {"b",FXFont::Bold},
  {"l",FXFont::Light},
  {"n",FXFont::Normal},
  {"r",FXFont::Normal},
  {"m",FXFont::Medium},
  };


// Search for value and return name
static FXString findbyvalue(const ENTRY* table,FXint n,FXuint value){
  for(int i=0; i<n; i++){ if(table[i].value==value) return table[i].name; }
  return FXStringVal(value);
  }


// Search for name and return value
static FXuint findbyname(const ENTRY* table,FXint n,const FXString& name){
  for(int i=0; i<n; i++){ if(comparecase(table[i].name,name)==0) return table[i].value; }
  return FXUIntVal(name);
  }


// Get font description
void FXFont::getFontDesc(FXFontDesc& fontdesc) const {
  strncpy(fontdesc.face,wantedName.text(),116);
  fontdesc.size=wantedSize;
  fontdesc.weight=wantedWeight;
  fontdesc.slant=wantedSlant;
  fontdesc.setwidth=wantedSetwidth;
  fontdesc.encoding=wantedEncoding;
  fontdesc.flags=hints;
  }


// Change font description
void FXFont::setFontDesc(const FXFontDesc& fontdesc){
  wantedName=fontdesc.face;
  wantedSize=fontdesc.size;
  wantedWeight=fontdesc.weight;
  wantedSlant=fontdesc.slant;
  wantedSetwidth=fontdesc.setwidth;
  wantedEncoding=fontdesc.encoding;
  hints=fontdesc.flags;
  }


// Change font description from a string
void FXFont::setFont(const FXString& string){
  FXint len;

  // Raw X11 font is only the name
  wantedName=string;
  wantedSize=0;
  wantedWeight=0;
  wantedSlant=0;
  wantedSetwidth=0;
  wantedEncoding=0;
  hints=FXFont::X11;

  // Normal font description
  len=string.find(',');
  if(0<=len){

    // Name and foundry
    wantedName=string.left(len);

    // Point size
    wantedSize=FXUIntVal(string.section(',',1));

    // Weight
    wantedWeight=findbyname(weighttable,ARRAYNUMBER(weighttable),string.section(',',2));

    // Slant
    wantedSlant=findbyname(slanttable,ARRAYNUMBER(slanttable),string.section(',',3));

    // Set width
    wantedSetwidth=findbyname(setwidthtable,ARRAYNUMBER(setwidthtable),string.section(',',4));

    // Encoding
    wantedEncoding=findbyname(encodingtable,ARRAYNUMBER(encodingtable),string.section(',',5));

    // Flags
    hints=FXUIntVal(string.section(',',6));
    }
  }



// Return the font description as a string; keep it as simple
// as possible by dropping defaulted fields at the end.
FXString FXFont::getFont() const {
  FXString string=wantedName;

  // Raw X11 font is only the name
  if(!(hints&FXFont::X11)){

    // Append size
    string.append(',');
    string.append(FXStringVal(wantedSize));

    // Weight and other stuff
    if(wantedWeight || wantedSlant || wantedSetwidth || wantedEncoding || hints){

      // Append weight
      string.append(',');
      string.append(findbyvalue(weighttable,ARRAYNUMBER(weighttable),wantedWeight));

      // Slant and other stuff
      if(wantedSlant || wantedSetwidth || wantedEncoding || hints){

        // Append slant
        string.append(',');
        string.append(findbyvalue(slanttable,ARRAYNUMBER(slanttable),wantedSlant));

        // Setwidth and other stuff
        if(wantedSetwidth || wantedEncoding || hints){

          // Append set width
          string.append(',');
          string.append(findbyvalue(setwidthtable,ARRAYNUMBER(setwidthtable),wantedSetwidth));

          // Encoding and other stuff
          if(wantedEncoding || hints){

            // Append encoding
            string.append(',');
            string.append(findbyvalue(encodingtable,ARRAYNUMBER(encodingtable),wantedEncoding));

            // Hints
            if(hints){

              // Append hint flags
              string.append(',');
              string.append(FXStringVal(hints));
              }
            }
          }
        }
      }
    }
  return string;
  }
}
    #+end_src
