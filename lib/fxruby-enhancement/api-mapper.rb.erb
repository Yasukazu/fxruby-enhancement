# coding: utf-8
=begin rdoc
This is the detailed mapper constructs for
FXRuby.

== Internal Docs
Note that normally you should not need to know these details.

=== Excution Flow
when you declare fx_app and all the nested delacrations,
they are initially noted in a tree of OS (OpenStruct) objects,
and then later the actual underlying FXRuby (and subsequently,
FOX Objects) are created. At this point the resultant objects
are plugged into the OS objects so they can be referenced.

So there are 3 phases:
# Construction of the OS tree (through your declaractions)
# Construction of the FXRuby objects
# Construction of the underlying FOX Objects at activation time.

A stack-based method is used to keep track of all of this during
the construction of the OS tree.

=== Issues
For many FOX / FXRuby operations, you will need the FXApp object.
If you used full composition (via fx_app), the base object will be
the FXApp object. If, on the other hand, you used compose inside
of a declared FXRuby-derived class, base will be set to the first
declared component. 

Normally this is not a problem, unless you use ingress_handler,
in which case it will not know how to find the FXApp object.

=== Conventions
* pos -- Parent OpenStruct object

== NOTE WELL
  This file is generated by fxruby-enhancement.
  Do NOT modify this file. Modify the ERB template
  file instead, and run 'rake scrape'.
=end

module Fox
<% for @class, @details in @api %>
   class <%= @class %>
     include Enhancement
     attr_accessor :_o
   end

   class E<%= @class %> < <%= @class %>
     <% @i=0 %>
     <% for @iniparams in @details[:initialize].compact %>
     def initialize(<%= @iniparams.map{ |p,d| "#{p}" + (d ? "=#{d}" : '')}.join(', ') %>)
       super
     end
     <% @i+=1; end unless @details[:initialize].nil? %>

     def self.compose tag, appref, &block
         <% @i=0 %>
         <% for @iniparams in @details[:initialize].compact %>
             <%= "@os.op[#{@i}]" %> = OpenStruct.new({<%= @iniparams.map{ |p,d| [p, d ? d : ":required"] }
                                                                 .map{ |p,d| ":#{p} => #{d}"}
                                                                 .join(', ') %>})
             <% for @param, @default in @iniparams %>
             def <%= "#{@param.snake}" %> var; @os.op[@os.ii].<%= "#{@param}" %> = var; end
             <% end %>
             def instance a=nil, &block
                @os.instance_name = a
                @os.instance_block = block
             end
         <% @i+=1; end unless @details[:initialize].nil? %>     
     end
   end
          
<% end %>
  module Enhancement
    module Mapper
    <% for @class, @details in @api %>
       def <%= @class.snake %> name = nil, ii: <%= (Fox::Enhancement::INITFORCE.member? @class) ? Fox::Enhancement::INITFORCE[@class] : 0 %>, pos: Enhancement.stack.last, &block
         Enhancement.stack << (@os = os = OpenStruct.new(klass: <%= @class %>, op: [], ii: ii, fx: nil, kinder: [], inst: nil, instance_result: nil))
         Enhancement.components[name] = os unless name.nil?
         unless pos.nil?
           pos.kinder << os 
         else
           Enhancement.base = os
         end
         <% @i=0 %>
         <% for @iniparams in @details[:initialize].compact %>
             <%= "@os.op[#{@i}]" %> = OpenStruct.new({<%= @iniparams.map{ |p,d| [p, d ? d : ":required"] }
                                                                 .map{ |p,d| ":#{p} => #{d}"}
                                                                 .join(', ') %>})
             <% for @param, @default in @iniparams %>
             def <%= "#{@param.snake}" %> var; @os.op[@os.ii].<%= "#{@param}" %> = var; end
             <% end %>
             def instance a=nil, &block
                @os.instance_name = a
                @os.instance_block = block
             end
         <% @i+=1; end unless @details[:initialize].nil? %>     
         self.instance_eval &block
         <% unless Fox::Enhancement::SPECIAL.member? @class %>
         os.fx = ->(){ <%= @class %>.new(*([pos.inst] + os.op[os.ii].to_h.values[1..-1])) }
         <% else %>
         os.fx = ->(){ <%= @class %>.new(*(os.op[os.ii].to_h.values)) }
         <% end %>
         Enhancement.stack.pop                                                  
         @os = Enhancement.stack.last
         os
       end
    <% end %>
    end
    <% for @select, @meth, @comment in @sel %>
    # <%= @comment %>
    def <%= @select.downcase %>(&block)
      self.connect(<%= @select %>, &block)
    end
    <% end %>                                                        
  end                                                      
end
